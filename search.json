[{"title":"Data Security","url":"/2022/03/09/Data_Security/","content":"本笔记用于记录大数据安全课上的知识点，用于准备期末考试以及后续的学习。在本门课中主要学习了大数据安全以及一些密码学算法。\r\n\r\n\r\n \r\n\r\n\r\n大数据安全总结Project\r\n\r\n\r\n--YH的学习笔记\r\n\r\n大数据绪论\r\n\r\n大数据基础概念\r\n==大数据安全内涵==\r\n==大数据安全威胁==\r\n传统数据安全的不足\r\n==保障大数据安全==\r\n大数据用于安全\r\n==隐私及其保护==\r\n大数据与物联网的关系\r\n\r\n物联网概述\r\n\r\n物联网的发展历史\r\n==物联网的定义==\r\n==物联网的主要特点==\r\n物联网与互联网的异同\r\n==物联网的架构==\r\n==物联网的关键技术==\r\n==物联网的技术形态==\r\n==物联网的具体应用场景==\r\n==物联网中的信息安全与隐私保护==\r\n\r\n古典密码学\r\n\r\n密码学发展及基本概念\r\n==古典密码学==\r\n\r\n对称密码--DES\r\n\r\n现代密码学重要思想\r\n==私钥密码==\r\n\r\n数论基础\r\n对称密码--AES\r\n\r\nAES基础知识\r\n密钥拓展\r\nAES的四个阶段\r\n\r\n公钥密码概念（非对称密码）\r\n\r\n对称密钥体制的缺陷\r\n公钥密码体制的基本思想\r\n公钥密码体制的优势\r\n公钥密码体制的应用\r\n传统密码与公钥密码\r\n公钥密码分析\r\n\r\nRSA加密算法\r\n\r\nRSA公钥加密体制原理\r\n\r\n椭圆曲线公钥密码体制\r\n\r\n椭圆曲线群\r\n椭圆曲线上的离散对数问题\r\n\r\n数字签名与消息认证\r\n\r\n数字签名概述\r\nRSA数字签名算法\r\nDSA数字签名算法\r\nECDSA数字签名算法\r\n\r\nHash函数\r\n\r\nHash函数的性质与应用\r\n对Hash函数的碰撞攻击方法\r\n基于分组密码算法的Hash函数\r\nMD5 Hash函数\r\n基于Hash函数的消息认证码\r\n\r\nD-H密钥交换协议&amp;ElGamal公钥密码算法&amp;椭圆曲线公钥密码算法\r\n\r\n有限域上的离散对数问题\r\nDiffie-Hellman公钥密码技术\r\nElGamal公钥密码算法\r\n\r\n人工智能安全\r\n大数据绪论\r\n==大数据的基础概念==\r\n\r\n大数据的定义：大数据是指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。\r\n特点：Volume规模大、Velocity变化快、Variety种类多、Value价值密度低 ，4V特性。\r\n\r\n==大数据安全内涵==\r\n\r\n保障大数据安全：保障大数据采集过程、计算过程、数据形态、应用价值的处理技术。\r\n大数据用于安全：利用大数据技术提升信息系统安全效能和能力的方法，涉及如何解决信息系统安全问题。\r\n\r\n==大数据安全威胁==\r\n\r\n大数据基础设施具有虚拟化和分布式特点，容易受到非授权访问、信息泄露或丢失、破坏数据完整性、拒绝服务攻击、网络病毒传播；\r\n大数据应用的生命周期中，数据存储是一个关键环节，尤其是非关系数据库带来如下安全挑战：模式成熟度不够、系统成熟度不够、服务器软件没有内置的足够的安全机制、数据冗余和分散性问题。\r\n网络安全是大数据安全防护的重要内容，安全问题随着网络节点数量的增加呈指数级上升；安全数据规模巨大，安全事件难以发现；安全的整体状况无法描述；安全态势难以感知等。\r\n网络化社会使大数据易成为攻击目标：在网络化社会中，信息的价值要超过基础设施的价值；一次攻击，效益大。\r\n大数据滥用的风险：\r\n\r\n大数据本身的安全防护存在漏洞，安全控制力度不够。\r\n攻击者利用大数据技术进行攻击，最大限度地收集更多用户敏感信息。\r\n\r\n大数据误用风险：大数据的准确性和数据质量不高，对其进行分析和使用可能产生无效的结果，从而导致错误的决策。\r\n\r\n传统数据安全的不足\r\n\r\n传统数据安全往往是围绕数据生命周期来部署，即数据的产生、存储、使用和销毁。由于大数据的规模没有上限，且许多数据的生命周期极为短暂，因此，常规安全产品想要继续发挥作用，则需要解决如何根据数据存储和处理的动态化、并行化特征，动态跟踪数据边界，管理对数据的操作行为等。\r\n随着大数据应用越来越多，数据的拥有者和管理者相分离，原来的数据生命周期逐渐转变成数据的产生、传输、存储和使用。数据以外包形式存储在云端。\r\n\r\n==保障大数据安全==\r\n\r\n围绕大数据全生命周期，即数据的产生、采集、传输、存储、处理、分析、发布、展示和应用、产生新数据等阶段进行安全防护。\r\n大数据保障技术可以从物理安全、系统安全、网络安全、存储安全、访问安全、审计安全、运营安全等角度进行考虑。\r\n保障大数据安全的目标：最大程度地保护具有流动性和开放性特征的大数据自身安全，防止数据泄露、越权访问、数据篡改、数据丢失、密钥泄露、侵犯用户隐私等问题的发生。\r\n对大数据全生命周期阶段合并与精简，大数据应用过程可划分为4个环节：采集、存储、挖掘和发布。\r\n\r\n==采集环节安全技术==\r\n\r\n安全威胁：数据损坏、丢失、泄露、窃取。\r\n安全机制：\r\n\r\n身份认证\r\n数据加密\r\n完整性保护\r\n抗重放攻击\r\n端到端的数据安全传输：采用SSL VPN（安全套接层，虚拟专用网），有Web浏览器模式、客户端模式、Lan到Lan模式。\r\n\r\n\r\n==存储环节安全技术==\r\n\r\n安全威胁：数据被窃取、丢失、破坏、机密数据泄露、隐私数据泄露。\r\n安全机制：\r\n\r\n隐私保护：数据变换、匿名化。\r\n数据加密：静态数据是指文档、报表、资料等不参与计算的数据—先加密再存储；动态数据是指需要检索或参与计算的数据—同态加密。\r\n备份与恢复：异地备份、RAID（独立磁盘冗余阵）、数据镜像、快照（数据副本、复制品）\r\n\r\n\r\n==挖掘环节安全技术==\r\n\r\n数据挖掘是大数据应用的核心部分，是发掘大数据价值的过程，即从海量的数据中自动抽取隐藏在数据中有用信息的过程，有用信息可能包括规则、概念、规律和模式等。\r\n安全威胁：第三方在进行数据挖掘的过程中植入恶意程序、窃取系统数据。\r\n安全机制：\r\n\r\n身份认证：基于秘密信息、基于信物、基于生物特征\r\n访问控制：自主访问控制DAC，可将拥有的权限自主地授予其他主体，并在随后的任何时刻将这些权限回收，控制是自主的；强制访问控制MAC—系统根据使用系统的机构事先确定的安全策略，对用户的访问权限进行强制性的控制，用户不能改变他们的安全级别或对象的安全属性；基于角色的访问控制RBAC—在用户和访问权限之间引入角色的概念，将用户和角色联系起来，通过对角色的授权来控制用户对系统资源的访问。\r\n\r\n\r\n==发布环节安全技术==\r\n\r\n发布是指大数据在经过挖据分析后，向数据应用实体输出挖掘结果数据的环节，即数据“出门”环节，必须对即将输出的数据进行全面的审查，确保输出的数据符合“不泄密、无隐私、不超限、合规约”等要求。\r\n安全威胁：泄密、泄露隐私、不合规范。\r\n安全机制：\r\n\r\n安全审计：基于日志的、基于网络监听的、基于网关的、基于代理的\r\n数据溯源：就是对大数据应用周期的各个环节的操作进行标记和定位，在发生数据安全问题时，可以及时准确地定位到出现问题的环节和责任者，以便于对数据安全问题的解决。溯源方法：标注法、反向查询法、数字水印。\r\n\r\n\r\n\r\n\r\n大数据用于安全\r\n\r\n安全监测与大数据的融合技术，利用大数据技术实时监控海量、多样、快速和复杂的数据，有效提高安全监测的效果和能力。\r\n大数据技术将极大扩展安全分析的深度和广度，把传统的数据安全分析的被动的事后分析变成主动地事前防御，能够更好地感知网络安全态势。\r\n在信息安全领域借助大数据处理技术，可以针对APT (Advanced Persistent Threat,高级持续性威胁，恶意商业间谍威胁)攻击隐蔽能力强、长期潜伏、攻击路径和渠道不确定等特征，设计具备实时检测能力与事后回溯能力的全流量审计方案。\r\n\r\n==隐私及其保护==\r\n隐私的基本概念\r\n​ 隐私是与个人相关的、具有不被他人搜集、保留和处分的权利的信息资料集合，并且它能够按照所有者的意愿在特定时间、以特定方式、在特定程度上被公开。\r\n​ 隐私的基本属性：保密性、个人相关、能够被所有者处分。\r\n​ 隐私分类\r\n\r\n个人隐私：任何可以确定特定个人或与可确定的个人相关，但个人不愿意暴露的信息，譬如：就诊记录。\r\n共同隐私：不仅包含个人隐私，还包含所有个人共同表现出但不愿意被暴露的信息，譬如：平均薪资。\r\n\r\n​ 信息时代的隐私权保护要比传统的隐私权保护重要得多。信息隐私权保护的客体可分为以下4个方面：\r\n\r\n个人属性的隐私权\r\n个人资料的隐私权\r\n通信内容的隐私权\r\n匿名的隐私权\r\n\r\n隐私的保护\r\n​ 隐私保护（Privacy Preserving）是对个人隐私采取一系列的安全手段防止其泄露和被滥用的行为。\r\n==隐私保护面临的威胁：==\r\n\r\n数据搜集：Internet服务提供商在搜集、下载、集中、整理和利用用户个人隐私资料极为方便。\r\n信息服务：个性化需求的信息服务需要用户提供更多的个人信息，才能提供更好的用户体验。\r\n搜索引擎：无法对自己搜索到的网页数据库信息进行监督，不会对搜索到的内容信息负责。\r\n数据挖掘：从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中，提取隐含在其中的、人们事先不知道的、但又是潜在有用的信息和知识的过程。\r\n\r\n==隐私保护面临大数据的威胁：==\r\n\r\n大数据时代带来信息存储和管理的集中化，一个大规模生产、分享和应用数据的时代，一切皆可量化，通过社交网络将社会关系和活动数据化，实现了过去不可想象的情绪数据化。\r\n大数据通常包含了大量的用户身份信息、属性信息、行为信息，在大数据应用的各阶段内，如果不能保护好大数据，极易造成用户隐私泄露。\r\n大数据的多源性，使得来自各个渠道的数据可以用来进行交叉检验，有可能发现匿名化数据后面的真实用户，因而导致隐私泄露。大数据时代，人们无法避免失去隐私。\r\n数据存储过程：大数据环境下，用户无法知道数据确切的存放位置，用户对其个人数据的采集、存储、使用、分享无法有效控制。\r\n数据传输过程：大数据环境下，数据传输将更为开放和多元化，传统物理区域隔离的方法无法有效保证远距离传输的安全性，电磁泄漏和窃听将成为更加突出的安全威胁。\r\n数据处理过程：大数据环境下，部署大量的虚拟技术，资源动态共享增加了访问控制和身份认证的管理难度，基础设施的脆弱性和加密措施的失效可能产生新的安全风险。\r\n\r\n大数据与物联网的关系\r\n物联网成为大数据的重要来源之一\r\n大数据为物联网的智能化发展提供有力保障\r\n\r\n建立与应用相关的数学模型\r\n运算系统的处理和计算\r\n多维度信息的整合和分析\r\n\r\n物联网概述\r\n物联网的发展历史\r\n发展阶段：\r\n\r\n概念模糊阶段\r\nRFID被广泛引用于物流、零售和制药领域、处于闭环的行业应用阶段\r\n万物互联\r\n\r\n==物联网的定义==\r\n\r\n==课程使用定义：==\r\n物联网是基于互联网、传统电信网等信息承载体，让所有能够寻址的物理实体实现互联互通，从而实现某种特定的功能业务的网络。\r\n\r\n==物联网的主要特点==\r\n\r\n联网终端规模化\r\n物联网时代每一件物品均具通信功能成为网络终端，5-10年内联网终端规模有望突破百亿。\r\n异构设备互联化\r\n各种异构设备利用无线通信模块和协议组网，异构网络通过“网关”互通互联。\r\n感知控制普适化\r\n无所不在的感知识别和决策控制将传统上分离的物理世界和信息世界高度融合。\r\n管理调度智能化\r\n在AI和大数据驱动（AIOT）和运筹学、数据挖掘专家系统等决策手段的帮助下，物联网将广泛应用于各行各业。\r\n应用服务链条化\r\n以工业生产为例，物联网技术覆盖从原材了引进、生产调度、节能减排、仓储物流到产品销售、售后服务等各个环节。\r\n经济发展跨越化\r\n物联网技术有望成为从劳动密集型向知识密集型，从资源浪费型向环境友好型国民经济发展过程中的重要动力。\r\n\r\n物联网与互联网的异同\r\n&lt;!DOCTYPE html&gt;\r\n\r\n\r\n\r\n\r\nDocument\r\n\r\n\r\n\r\n\r\n\r\n物联网与互联网的异同\r\n\r\n\r\n\r\n\r\n\r\n\r\n物联网\r\n\r\n\r\n互联网\r\n\r\n\r\n\r\n\r\n\r\n\r\n相同点\r\n\r\n\r\n技术基础相同\r\n\r\n\r\n物联网和互联网都是建立在分组数据技术的基础之上的，它们都采用分组交换网（packet switching network）作为它们的承载网.物联网技术的重要基础和核心仍是互联网，通过有线和无线网络与互联网融合，实现人和物体、物体与物体之间的沟通和对话。\r\n\r\n\r\n\r\n\r\n不同点\r\n\r\n\r\n涵盖范围\r\n\r\n\r\n物联网是让物自由地交换信息，主要是为了管理物，间接为人服务。\r\n\r\n\r\n互联网是让人通过网络交换信息，服务的对象是人。\r\n\r\n\r\n\r\n\r\n终端接入方式\r\n\r\n\r\n物联网中的物联网节点需要通过末端网络接入到网络汇聚点，然后连接至互联网，如无线传感器网络，物联网的接入网络和互联网有很多重合\r\n\r\n\r\n互联网用户通过接入网络将终端（end host）接入互联网，访问互联网资源\r\n\r\n\r\n\r\n\r\n技术范围\r\n\r\n\r\n物联网运用的技术主要包括无线技术、互联网、智能芯片技术、软件技术，几乎涵盖了信息通信技术的所有领域\r\n\r\n\r\n互联网只是物联网的一个技术方向。互联网只能是一种虚拟的交流，而物联网实现的就是实物之间的交流\r\n\r\n\r\n\r\n\r\n\r\n\r\n物联网的架构\r\n物联网体系架构概述\r\n\r\n定义：具体系统在实际设计过程中的指导性架构\r\n问题：应用范围广、行业涉及多、设计诉求不同\r\n需求：跨平台、跨应用的通用物联网体系架构\r\n\r\n==应用层-网络层-感知层架构==\r\n\r\n应用层：包括应用基础设施/中间件和各种物联网应用。\r\n网络层：主要实现信息的传递、路由和控制，包括延伸网、接入网和核心网，网络层可依托公众电信网和互联网，也可以依托行业专用通信网络。\r\n感知层：实现对物理世界的智能感知识别、信息采集处理和自动控制，并通过通信模块将物理实体连接到网络层和应用层。\r\n\r\n==“云-管-边-端”的物联网体系架构==\r\n物联网结构从上至下可被分为“云-管-边-端”四个层次\r\n\r\nimage-20211206133058415\r\n\r\n“云”：物联网业务的载体，面向物联网感知和决策的各种数据，基于人工智能和大数据技术，通过数据分析和处理实现某种特定功能业务的资源池。可以被看作一个提供资源的网络，用户可以根据业务按需使用。\r\n“管”：指接入网络和数据传输协议，负责终端节点间、终端节点与边缘节点、边缘节点与云之间数据的传输和控制指令的下发。如基础设施网络协议、工控网络协议、未知协议和私有协议的使用。物联网的“管”侧趋于多元化。\r\n“边”：部署在靠近终端设备的边缘节点，终端设备的部分数据直接在边缘节点进行处理，无需上传到云端。特点：分布式和低延时、高效率、智能化、节能、缓解带宽压力等\r\n“端”：物联网感知物理世界的接口，由种类繁多的海量智能设备构成，呈现出异构化的特点，是执行感控的主体。\r\n物联网的关键技术\r\n物联网基本功能的实现依托于对物理环境的感知、数据的传输以及数据的处理，基于此，现阶段物联网的关键技术主要包括：传感器技术、通信技术、无线接入技术、云计算、边缘计算、人工智能等。\r\n\r\n==通信及组网技术==\r\n\r\n通信技术可分为有线通信和无线通信，用于实现“物与物”之间数据和指令的传输。\r\n有线通信的可靠性更高，但对系统的部署条件有所约束；无线通信的方式提高了系统部署的灵活性，但存在更高的数据传输误码、丢包概率。\r\n\r\n无线接入技术\r\n\r\n无线接入技术（radio interface technologies，简称RIT ） ，也称空中接口，是无线通信的关键问题。它是指通过无线介质将用户终端与网络节点连接起来，以实现用户与网络间的信息传递。\r\n无线接入技术可以分为固定接入技术和移动接入技术，典型的无线接入系统主要由无线网络用户、基站、无线连接和自组网等几个部分组成。\r\n常用的无线接入技术主要包括WiFi、ZigBee、WiMAX、3G/4G/5G等。\r\n\r\n云计算\r\n\r\n云计算是随着虚拟化技术、处理器技术、分布式计算技术、宽带互联网技术和自动化管理技术的发展而产生的。\r\n物联网大量的终端设备采集到了海量的数据，往往超出了终端设备的处理能力。为解决这一问题，物联网考虑将数据上传到云端，借助云端丰富的计算和存储资源满足物联网大量终端设备的数据、控制指令的处理需求。\r\n云计算的数据传输成本较高，难以满足边缘业务的实时性需求，一些敏感业务的隐私数据上传也存在着安全隐私风险，如病患隐私数据\r\n\r\n边缘计算\r\n\r\n边缘计算/雾计算，是指在靠近物或数据源头的一侧，采用网络、计算、存储、应用核心能力为一体的开放平台，就近提供最近端服务\r\n作为云计算的补充和优化，边缘计算在靠近终端节点的边缘部署计算节点，利用分布式计算思想，提供低延迟、智能化的高效计算，以满足诸如车联网一类实时性要求较高的业务的需求\r\n\r\n人工智能\r\n\r\n物联网的大量终端设备所采集的数据为人工智能在物联网的应用提供了数据基础，同时人工智能的融入推动了物联网实现智能化\r\n智慧物联网(AIoT) 是结合人工智能以及物联网的技术所形成的\r\n同时，AIoT中的AI算法具有脆弱性，如逃逸攻击等带来的安全隐私问题\r\n\r\n\r\n物联网的技术形态\r\n自动识别技术与RFID\r\n\r\n自动识别技术\r\n\r\n光学字符识别\r\n语音识别\r\n虹膜识别\r\nIC卡识别\r\n条形码识别\r\n\r\n一维条形码\r\n二维条形码\r\n\r\n\r\n\r\n无线定位系统\r\n\r\n基于位置的服务\r\n==定位系统==\r\n\r\n卫星定位系统：汽车导航\r\n\r\n优点：\r\n\r\n精度高\r\n全球覆盖，可用于险恶环境\r\n\r\n缺点：\r\n\r\n启动时间长：若干分钟搜星\r\n室内信号差\r\n需要GPS接收机\r\n\r\n\r\n蜂窝基站定位：紧急电话定位\r\n\r\n优点：\r\n\r\n不需要GPS接收机，可通讯即可定位\r\n启动速度快\r\n信号穿透能力强，室内亦可接收到\r\n\r\n缺点\r\n\r\n定位精度相对较低\r\n基站需要有专门硬件，造价昂贵\r\n\r\n\r\nA-GPS：\r\n\r\n利用基站定位确定大致范围\r\n连接网络查询当前位置可见卫星\r\n大大缩短搜索卫星的时间\r\n\r\n室内精确定位：\r\n\r\n优点：结构简单、易于安装、成本低\r\n缺点：距离短、室内环境复杂\r\n\r\n\r\n==常用定位定位方法==\r\n\r\n基于距离（时间）的定位\r\n根据声波的传播时间来测量节点间的距离。缺点：传播速度容易受到大气条件的影响，节点之间要求保持精确的时间同步。\r\n基于距离（时间）差的定位\r\n发射节点和接收节点同时发射两种不同传播速度的无线信号，接收节点根据两种信号到达的时间差及已知这两种信号的传播速度，计算两节点之间的距离。缺点：对硬件要求高。\r\n基于信号特征的定位\r\n这是指发射信号强度已知，用户节点定期发射信号分组，各基站根据接收到的信号强度计算传播损耗。\r\n\r\n\r\n物联网的具体应用场景\r\n\r\n==应用场景分类==：基础设施、产业应用、商业服务和消费电子\r\n\r\nimage-20211206173535303\r\n\r\n工业物联网\r\n车联网\r\n电力物联网\r\n智能家居\r\n\r\n物联网中的信息安全与隐私保护\r\n\r\n==物联网安全与隐私问题的一般性指标==\r\n\r\n可靠性：三种测度标准（抗毁、生存、有效）\r\n可用性：用正常服务时间和整体工作时间之比衡量\r\n保密性\r\n完整性：未经授权不能改变信息；\r\n不可抵赖性\r\n可控性：对信息传播和内容的控制特性\r\n\r\nTips:保密性要求信息不被泄露给未授权的人，完整性要求信息不受各种原因破坏。\r\n\r\n古典密码学\r\n密码学发展及基本概念\r\n==古典密码阶段：==\r\n\r\n特点：出现密码算法设计的基本手段（代替法、置换法）\r\n保密性：数据的保密基于加密算法的保密\r\n\r\n==现代密码Ⅰ阶段：==\r\n\r\n新特点：数据的安全基于密钥而不是算法的保密\r\n扩散：将每一位明文尽可能散布到多个输出密文中，以更隐蔽明文数字的统计特性\r\n混淆：使密文的统计特性与明文之间的关系尽量复杂\r\n\r\n==现代密码Ⅱ阶段：==\r\n\r\n公钥密码出现\r\n\r\n==信息安全的目标：==\r\n\r\n机密性：保证信息/数据不会被泄露给未经授权的个体\r\n\r\n防御方法：加密解密算法\r\n\r\n完整性：保证信息/数据不会被未经授权的个体修改\r\n\r\n防御方法：Hash函数、纠错码、消息认证码\r\n\r\n可用性：保证信息/数据能被授权的个体访问\r\n真实性：保证信息/数据确实来自其所声称的消息源\r\n\r\n防御方法：密码方案、数字签名、Hash函数、消息认证码、质询-响应协议\r\n\r\n不可抵赖性：保证信息/数据交互的所有参与者均不能否认曾经发送过的消息和数据\r\n\r\n防御方法：数字签名\r\n\r\n\r\n==密码学技术分类：==\r\n\r\nimage-20211207134634582\r\n\r\n==密码学基本概念：==\r\n\r\n明文：需要秘密传送的信息\r\n密文 ：明文经过密码变换后的消息\r\n加密：由明文到密文的变换\r\n解密 ：从密文恢复出明文的过程\r\n破译：非法接收者试图从密文分析出明文的过程\r\n密钥：加密和解密时使用的一组秘密信息\r\n加密/解密算法：对明/密文进行加/解密时的规则\r\n\r\n==柯克霍夫假设：==\r\n密码分析者知道双方使用的密码系统，包括明文的统计特性、加密解密体质等，唯一不知道的是密钥。\r\n==密码分析学==\r\n\r\nimage-20211225153050921\r\n\r\n==攻击的分类：==\r\n\r\n唯密文攻击: 攻击者有一个或多个密文，攻击需要统计分析；\r\n已知明文攻击: 攻击者有一份密文和对应的明文，进行算法和密钥推导；\r\n选择明文攻击: 攻击者有机会使用加密机，因此可以选择任何明文并产生对应的密文，攻击概率更大；\r\n选择密文攻击: 攻击者有机会使用解密机，因此可以选择一些密文并产生对应的明文。\r\n\r\n==古典密码学==\r\n凯撒加密/位移加密（==计算==）\r\n\r\n==算法过程==\r\n\r\n建立英文字母和模26的剩余之间的对应关系\r\n加密过程：\\(y=x+k(\\bmod 26)\\)\r\n解密过程：\\(x=y-k(\\bmod 26)\\)\r\n\r\n\r\n​ 其中，k就是加密密钥。\r\n\r\n==攻击方法：==\r\n\r\n暴力穷举\r\n词频统计\r\n\r\n统计密文中字母出现的频率\r\n与标准的语言字母出现的频率进行比对\r\n确定密钥k的最可能值\r\n\r\n\r\n\r\n仿射密码\r\n\r\n算法过程\r\n\r\n确定密钥（α，β）α，β∈\\(Z_{26}\\)\r\n加密：\\(y=\\alpha x+\\beta(\\bmod 26)\\)\r\n解密：\\(x=\\frac{1}{\\alpha}(y-\\beta)(\\bmod 26)\\)\r\n\r\n\r\n​ Tips：计算过程中，应该首先确定α的逆元。\r\n\r\n仿射加密安全性：\r\n\r\n定理：对于a，如果相对模数n存在逆元，则需满足gcd(a,n)=1。因此，仿射加密种类少。\r\n\r\n仿射加密的攻击：\r\n\r\n暴力穷举：312\r\n词频统计：使用两组来求两个变量\r\n\r\n\r\n维吉尼亚密码\r\n\r\n算法过程：\r\n\r\n列出明文并按照密钥长度分组\r\n用密钥对每个组内字母进行移位加密\r\n加密公式：\\(C=P+K(\\bmod 26)\\)\r\n\r\n特点：\r\n\r\n移位密码的扩展\r\n消除字母的频率特征\r\n\r\n破解维吉尼亚密码：\r\n\r\n找到密钥长度\r\n\r\nKasiski实验\r\n\r\n统计相同明文，出现相同密钥的间隔\r\n密钥长度为间隔数的约数，公约数计算\r\n\r\nFriedman测试\r\n\r\n重合指数表示两个随机选出的字母是相同的的概率，即随机选出两个A的概率+随机选出两个B的概率+随机选出两个C的概率+……+随机选出两个Z的概率\r\n\r\n频率分析\r\n\r\n找出密钥：把密文按照密钥长度L，选出密文中的第1、L+1个...字母进行词频统计，就可以得到第一个密钥字母。依此类推，继续寻找下一个。\r\n\r\n\r\n对称密码--DES\r\n现代密码学重要思想\r\n\r\n==流密码与分组密码==\r\n\r\n流密码：每次加密数据流的一位或者一个字节；\r\n分组密码：将明文分组作为整体加密并且通常得到与明文等长的密文分组\r\n\r\n==混淆和扩散==\r\n\r\n混淆：使密钥和密文之间的关系尽可能模糊的加密操作\r\n扩散：为了隐藏明文统计属性而将一个明文符号的影响扩散到多个密文符号的加密操作，如位置换。通常修改明文中1位会导致平均一半的输出位发生变化。\r\n\r\n==分组密码算法应满足的要求==（选择题或者填空题）\r\n\r\n分组长度N要足够大，防止明文穷举法攻击\r\n密钥量要足够大，尽可能消除弱密钥并使所有密钥同等地好，以防止密钥穷举攻击奏效\r\n由密钥确定置换的算法要足够复杂，充分实现明文与密钥的扩散和混淆，没有简单的关系可循，要能抗击各种已知的攻击\r\n加密和解密运算简单，易于软件和硬件高速实现。\r\n数据扩展，一般无数据扩展，在采用同态置换和随机化加密技术时可引入数据扩展。\r\n差错传播尽可能地小，一个密文分组的错误尽可能少的影响其他密文分组的解密\r\n\r\n==Feistel密码==\r\n\r\nFeitel密码的思想\r\n\r\n乘积密码是顺序地执行两个或多个基本密码系统。\r\nFeistel还提出了实现代换和置换的方法。\r\n\r\nFeistel密码参数\r\n\r\n分组大小: 分组越大则安全性越高，但加密速度就越慢。\r\n密钥大小：密钥越长则安全性越高，但加密速度就越慢。\r\n轮数：单轮结构远不足以保证安全性，但多轮结构可提供足够的安全性。典型地，轮数取为16。\r\n子密钥产生算法：该算法的复杂性越大，则密码分析的困难性就越大。\r\n轮函数：轮函数的复杂性越大，密码分析的困难性也越大。\r\n\r\n设计Feistel的两个要求\r\n\r\n快速的软件实现：在很多情况中，算法是被镶嵌在应用程序中，因而无法用硬件实现。此时算法的执行速度是考虑的关键。\r\n算法容易分析：如果算法能被无疑义地解释清楚，就可容易地分析算法抵抗攻击的能力，有助于设计高强度的算法。\r\n\r\n==Feistel加密结构==\r\n\r\n输入是分组长为 \\(2 w\\) 的明文和一个密钥 \\(K\\) 。将每组明文分成左 右两半 \\(L_{0}\\) 和 \\(R_{0}\\), 在进行完 \\(n\\) 轮迭代后, 左右两半再合并到一起 以产生密文分组。第 \\(i\\) 轮迭代的输入为前一轮输出的函数:\r\n\r\n\\[\r\n\\begin{aligned}\r\nL_{i} &amp;=R_{i-1} \\\\\r\nR_{i} &amp;=L_{i-1} \\oplus F\\left(R_{i-1}, K_{i}\\right)\r\n\\end{aligned}\r\n\\]\r\n\r\n其中 \\(K_{i}\\) 是第 \\(i\\) 轮用的子密钥, 由加密密钥 \\(K\\) 得到。一般地, 各 轮子密钥彼此不同而且与 \\(K\\) 也不同。\r\nFeistel解密过程本质上和加密过程是一样的, 算法使用密文作为输入\r\n但使用子密钥 \\(K_{i}\\) 的次序与加密过程相反, 即第 1 轮使用 \\(K_{n}\\), 第 2 轮 使用 \\(K_{n-1}, \\ldots \\ldots\\), 最后一轮使用 \\(K_{1}\\) 。这一特性保证了解密和加密 可采用同一算法。解密过程： \\[\r\n\\begin{aligned}\r\n&amp;R E_{i-1}=L E_{i} \\\\\r\n&amp;L E_{i-1}=R E_{i} \\oplus F\\left(R E_{i-1}, K_{i}\\right)=R E_{i} \\oplus F\\left(L E_{i}, K_{i}\\right)\r\n\\end{aligned}\r\n\\]\r\n\r\nimage-20211225154513116\r\n\r\n算法的准确性：\r\n\r\nimage-20211225154738498\r\n\r\n\r\nimage-20211225154830107\r\n\r\n\r\n\r\n\r\n私钥密码（对称密码）\r\n通信流程：\r\n\r\nimage-20211207193418889\r\n\r\n对称加密安全性保证：\r\n\r\n加密算法具有安全性\r\n通信双方通过安全信道获得对方的密钥并进行安全存储。该条件要求密钥具有保密性（关键）。\r\n\r\n==DES==\r\n\r\n==定义==：一种使用56位密钥对64位长分组进行加密的密码，是一种迭代算法。DES是第一个公开的分组加密算法。\r\n==特点==：DES对明文中每个分组的加密过程都包含16轮，且每轮的操作都完全相同。每轮使用不同的子密钥，但是子密钥是从主密钥中推导而来。\r\n\r\n\r\nimage-20211207194125722\r\n\r\n\r\n==DES算法加密流程==：初始置换IP、16轮迭代的乘积变换、逆初始置换\\(IP^{-1}\\)以及16个子密钥产生器。（不好出计算题，不会出最终的加密的密文，但是需要了解整体的流程，会考虑中间的环节）\r\n\r\nimage-20211207194346373\r\n\r\n初始置换IP：得到了一个乱序的比特明文分组\r\n\r\nimage-20211207194936698\r\n\r\n轮内加密：\r\n\r\nimage-20211207200747905\r\n\r\n==DES的核心--F函数==：实现了混淆和扩散的功能\r\n\r\nimage-20211207203226736\r\n\r\n\r\n扩展置换E盒\r\n\r\nimage-20211207204807351\r\n\r\n\r\nimage-20211207204748671\r\n\r\nS盒：对于一个六比特的二进制数，使用S盒对其进行缩短。分别以中间的四比特和两边的两个比特作为index查表。\r\n\r\nimage-20211207205730047\r\n\r\n置换P：\r\n\r\nP盒的各输出块得4个比特都来自不同的输入块\r\nP盒的各输入块的4个比特都分配到不同的输出块之中\r\nP盒的第t输出块的4个比特都不来自第t输入块\r\n\r\n\r\nimage-20211207210545350\r\n\r\n\r\n==DES密钥生成==\r\n\r\nimage-20211207212222011\r\n\r\nFeistel每轮中仅加密（解密）输入位的一半，F函数只加密左半部分，不加密右半部分。DES优势之一就是解密的过程和加密过程完全相同，只是解密过程第i轮需要用到第16-i轮到密钥\r\n\r\n==多重DES==\r\n\r\nimage-20211225155316907\r\n\r\n\r\nimage-20211225155306117\r\n\r\n==优点：==\r\n\r\n密钥长度增加到112位或168位，克服DES面临的穷举攻击\r\n相对于DES，增加了抗差分分析和线性分析等的能力\r\n由于DES已大规模使用，升级到3DES比更新算法成本小得多\r\nDES比其他任何加密算法受到的分析时间都长的多，3DES抗分析能力更强\r\n\r\n==缺点：==\r\n\r\n3DES处理速度慢\r\n明文分组长度没变，与密钥长度的增长不匹配\r\n\r\n==面临的问题：==\r\n\r\n实现效率\r\n安全性\r\n\r\n数论基础\r\n欧几里得算法求最大公约数（涉及计算题）\r\n欧几里得求逆元\r\n\r\nimage-20211225155614226\r\n\r\n==模运算的性质==\r\n\r\nimage-20211225155531275\r\n\r\n欧拉定理和费马小定理\r\n\r\nimage-20211225155654329\r\n\r\n\r\nimage-20211225160005389\r\n\r\n\r\nimage-20211225160046524\r\n\r\n\r\nimage-20211225160103432\r\n\r\n\r\nimage-20211225160129532\r\n\r\n\r\nimage-20211225160141859\r\n\r\n对称密码--AES\r\nAES基础知识介绍\r\n==高级加密标准==（Advanced Encryption Standard）：明文分组为128位、支持3种密钥长度（128、192、256）且软硬件实现都很高效。\r\n==AES评估标准==\r\n\r\n一般安全性：密码学界公共安全分析\r\n软件实现：软件执行速度，跨平台执行能力及密钥长度改变时速度变化\r\n受限空间环境\r\n硬件实现：硬件实现时能够提高执行速度或缩短代码长度\r\n抵御密码分析攻击\r\n密钥灵活性：快速改变密钥长度\r\n其他的多功能性和灵活性\r\n指令集并行执行潜力\r\n\r\n==AES参数设置==：\r\n\r\nimage-20211220105540997\r\n\r\n==出题方向：对应密钥长度时迭代轮式是多少？==\r\nAES结构：\r\n\r\n==非Feistel结构==\r\n==密钥被扩展==成由44个32位字组成的数组，每轮使用4个。\r\n==一个混淆和三个代换==\r\n\r\n字节代换：用一个S盒完成分组中的按字节代换\r\n行移位：一个简单的置换\r\n列混淆：利用在伽罗瓦域上的算术特性的代换\r\n轮密钥加：利用当前分组和扩展密钥的一部分进行按位XOR\r\n\r\n算法结构简单，仅在轮加密阶段中使用密钥\r\n轮密钥加配合其他三个混淆的交替使用提供了安全性\r\n每个阶段均可逆，解密按逆序方式使用扩展密钥，但是算法不一样\r\n一旦将四个阶段求逆，可以证明解密函数可以恢复明文\r\n加密和解密过程的最后一轮均只包括三个阶段\r\n\r\n\r\nimage-20211220110010268\r\n\r\n密钥拓展\r\n\r\nimage-20211220115803701\r\n\r\n具体方法：其中每一轮拓展的第一个使用Rcon。首先将第一组的第一个进行一个列的移位，然后使用s盒得到一个新列，然后进行异或。最后得到第一列。这一组的另外三列分别与这一组上一列以及上一组的对应列异或得到。\r\ntips：s盒的使用方法是将前四位作为行，后四位作为列，对应数字对其进行替换。\r\nAES的四个阶段\r\n字节替代（Substitute bytes）\r\n\r\n查表法：使用s盒对其进行替换\r\n计算方式：\r\n\r\nimage-20211220120715146\r\n\r\n\r\n行移位（ShiftRows）\r\n\r\n移动规则：第一行不变、第二行左移一个字节、第三行两个、第四行三个\r\n\r\n列混淆（MixColumns）\r\n\r\n每一列单独处理\r\n每列中每个字节被替换成与本列四个字节都相关的结果\r\n基于伽罗瓦域的运算\r\n\r\n\r\nimage-20211220133810712\r\n\r\ntips：伽罗瓦域也就是有限域，因此，使用有限域上的运算规则\r\n轮密钥加（AddRoundKey）\r\n将16字节的当前状态矩阵和长度为16字节的子钥进行异或\r\n公钥密码概念（非对称密码）\r\n==对称密钥体制的缺陷==\r\n\r\n对称密码体制(例如DES, AES) 允许两个用户利用提前共享的秘密来建立“安全信道” ，然而通信双方共享秘密并不容易。\r\n考虑一个具有N个用户的团体，如果用户两两之间都需要进行安全通信，采用对称密码体制来保护用户之间的通信: 每个用户需要与其余的N -1个用户共享私钥，整个系统需要管理N(N -1)/2个密钥。\r\n无法保证可追溯性\r\n不支持开放系统\r\n\r\n==公钥密码体制的基本思想==\r\n\r\n密钥生成：通过相对容易的计算过程生成一对公钥PK与私钥SK。\r\n\r\n如果仅获得公钥PK，得到私钥SK的操作在计算上是不可行的。\r\n\r\n加密: 给定明文M与公钥PK，很容易计算得到密文\\(C=E_{PK}(M)\\)\r\n解密: 给定密文\\(C=E_{PK}(M)\\) 和私钥SK，很容易计算得到明文M\r\n如果缺少私钥SK，从密文C中是不可以计算得到明文M的。\r\n不可以：在当前的计算能力条件下，计算时间和密钥长度呈指数增长关系。\r\n\r\n==公钥密码体制的优势==\r\n\r\n密钥分发： 公钥能够采用公开（认证的）信道进行传输；\r\n密钥管理： 在N个用户的系统中，每个用户只需安全保管自己的私钥和N-1个其他用户的公钥。整个系统仅仅需要维护N个公钥；\r\n开放系统：即使是没有预先建立关系的用户也能通过对方的公钥建立安全通信。\r\n\r\n==公钥密码体制的应用==\r\n\r\n加密/解密：发送方使用接收方的公钥对消息加密\r\n签名：发送方使用私钥对消息”签名“\r\n密钥交换：通信双方交换会话密钥\r\n\r\n==传统密码与公钥密码==\r\n\r\nimage-20211220111739332\r\n\r\n==公钥密码分析==\r\n\r\n穷举攻击：长密钥、加/解密速度慢，所以用于密钥管理和签名\r\n给定公钥计算私钥：还未证明不可行\r\n穷举消息攻击：假定要发送的消息是56位的DES密钥，那么攻击者可以对所有可能的密钥加密，并于传送的密文匹配，从而可解密任何DES加密的消息。防御方法：发送的消息后附加一个随机数，因此，无法匹配。\r\n\r\nRSA加密算法\r\n==RSA公钥加密体制原理==（计算题，不考证明）\r\n\r\n密钥生成：\r\n\r\n选择两个大素数p,q(例如：每个数字1024位)\r\n选择\\(n=p*q\\)，\\(z =\\phi(n) = (p-1)*(q-1)\\)\r\n随机选取e（其中e&lt;n），e与z没有公约数。（e，z“互为质数”）\r\n选取 d 使得 ed-1 能够被z完全整除。（即ed mod z = 1）\r\n公钥是 (n, e) ，私钥是（n, d）。\r\n\r\n加解密算法\r\n\r\n加密：由\\(c=m^e mod n\\) 将明文m转变为密文c。\r\n解密：\\(m=c^d mod n\\)。\r\n\r\n核心思想：\r\n\r\nimage-20211220113131128\r\n\r\n问题本质：素分解问题\r\n\r\n==RSA安全性分析==（知道攻击手段即可，不用知道具体的实现过程）\r\n\r\n穷举攻击\r\n数学攻击\r\n计时攻击\r\n基于硬件故障的攻击\r\n选择密文攻击\r\n\r\nD-H密钥交换协议&amp;ElGamal公钥密码算法&amp;椭圆曲线公钥密码算法\r\n==有限域上的离散对数问题==\r\n定义：设F是一个有限域，则在F中的元a和b，求解整数x，使得：\\(a^x = b\\)在有限域F中成立的问题，称为有限域F上的离散对数问题。\r\n最好的算法：数域筛法\r\n==Diffie-Hellman公钥密码技术==（计算题）\r\n目的：实现双方在不安全通信信道下交流得到一个共同密钥。\r\n==本元根==\r\n设素数p，则Z/(p)构成一个有限域，因而其非零元全体模p乘法构成循环群。本原根的两种定义：\r\n\r\n设a∈{1，2，…, p-1}，如果\\(min\\{t&gt;0: at = 1\\} = p – 1\\)，则称a是Z/(p)的本原根\r\n如果a是Z/(p)的本原根，且其幂可以产生1到p-1之间的所有整数，即$ Z/(p)= {0, a mod p, a^2modp,…, a^{p-1}modp = 1}$。它是整数1到p-1的一个置换。\r\n\r\n==D-H公钥技术==\r\n\r\n参数选取：选取一个大素数\\(p\\)，在选取\\(Z/(p)\\)的一个本原根\\(g\\)，并将\\(p\\)和\\(g\\)公开。\r\n密钥协商：\r\n\r\n其中，\\(a,b∈[1,p-2]\\)。\r\n\r\n==DH协议==\r\n优点：\r\n\r\n任何两个人都可以协商出会话密钥，不需要事先拥有对方的公开或者秘密的信息。\r\n每次密钥交换后不必要在保留秘密信息，减少了保密的负担。\r\n\r\n缺点：\r\n\r\n容易受到中间人攻击\r\n\r\n\r\n==ElGamal公钥密码算法==（计算）\r\n明文空间：\\(M=GF(q)/\\{0\\}\\)\r\n密文空间：\\(M×M=\\{(x,y):x,y∈M\\}\\)\r\n\r\n参数选取：选取有限域\\(GF(q)\\)，再选取有限域\\(GF(q)\\)的一个本原根\\(a\\)，并对其公开。随机选取整数\\(d：1≤d≤q-2\\)，并计算出\\(β = a^d\\)。\\(β\\)作为公开的加密密钥，\\(d\\)解密密钥。\r\n加密算法：对\\(M=GF(q)/\\{0\\}\\)，秘密选择一个随机整数\\(k: 1 ≤ k ≤ q -2\\)，则密文\\(c = (c1, c2) ∈ M × M\\)，其中 \\[\r\nc_{1}=a^{k} \\text { 和 } c_{2}=m \\beta^{k}\r\n\\]\r\n解密算法：对任意密文\\(c = (c1, c2) ∈ M × M\\)，计算明文\\(m = c_2{({c_1}^d)}^{-1}\\)\r\n\r\n==tips==:\r\n\r\n本原根a和GF(q)可以全网公用，也可以一人一套；\r\n本原根a可以用阶是大素数的a代替；\r\n加密不同的明文分组时必须选用独立的随机数k，但秘密的解密密钥d 需要和其版本号一起长期不变。\r\nq-1必须有大的素因子\r\nq的位数应在1024bytes以上\r\n\r\n椭圆曲线公钥密码体制\r\n优点：较短的密钥、运算速度快，适合计算资源和存储空间受限的应用环境\r\n椭圆曲线群\r\n\r\nimage-20211220151209605\r\n\r\n\r\nimage-20211220151618295\r\n\r\n\r\nimage-20211220151632480\r\n\r\n\r\nimage-20211220151642330\r\n\r\n椭圆曲线上的加法\r\n\r\nimage-20211220151807488\r\n\r\n\r\nimage-20211220151903280\r\n\r\n\r\nimage-20211220151936248\r\n\r\n椭圆曲线上的离散对数问题\r\n\r\nimage-20211220151958465\r\n\r\n\r\nimage-20211220152011515\r\n\r\n\r\nimage-20211220152209576\r\n\r\n参数设置：\r\n\r\nimage-20211220152551895\r\n\r\n公私钥对：\r\n\r\nimage-20211220152535190\r\n\r\n加密算法：\r\n\r\nimage-20211220152617361\r\n\r\n解密算法：\r\n\r\nimage-20211220152630136\r\n\r\n数字签名与消息认证\r\n数字签名概述\r\n==数字签名应满足的条件：==\r\n\r\n签名应与文件是一个不可分割的整体。实现：对消息进行某种变换完成签名；使签名是待签名的文件的函数。\r\n签名者时候不能否认自己的签名。实现：签名是通过发方所独有的秘密信息来完成，并且该秘密信息对应惟一公开的验证信息，使签名者不能抵赖自己的签名。\r\n接收者能验证签名，而任何其他人都不能伪造签名；实现：签名必须与特定的公开信息相对应，使收方能够验证；签名应与签名者独有的秘密信息密切相关，使其他人不能伪造。\r\n当双方关于签名的真伪发生争执时，一个法官或第三方能解决双方之间发生的争执。 实现：签名对应的验证密钥应由可信的第三方确认并公布。当发生争执时，靠法律解决争端。\r\n\r\n==数字签名方案的分类==\r\n\r\n==利用特殊的公钥加密算法实现==\r\n条件：满足\\(D_{k_{u}}\\left(E_{k_{\\text {a }}}(x)\\right)=E_{k_{\\text {a }}}\\left(D_{k_{\\text {d }}}(x)\\right)=x\\)的公钥密码算法。其中D是脱密算法，E是加密算法。\r\n设计方法：用户将私钥作为签名密钥，公钥作为签名识别密钥\r\nA用户签名过程：\r\n\r\n利用签名密钥\\(k_d\\)对文件\\(m\\)进行脱密变换\\(D\\)，得到签名\\(sign(n)=D_{k_d}(m)\\)。\r\n签名者将文件\\(m\\)及其签名\\(sign(m)\\)一起公布\r\n\r\nB用户识别过程：\r\n\r\n利用用户A的签名识别密钥\\(k_e\\)对签名\\(sign(m)\\)执行加密变换\\(E\\)。\r\n\r\n仲裁过程：与识别过程相似\r\n利用专门设计的数字签名算法实现\r\n\r\n数字签名：数字签名（又称公钥数字签名）是只有信息的发送者才能产生的别人无法伪造的一段数字串，类似于手写签名，可保证每个用户都可验证信息来源，是对信息的发送者身份真实性的一个有效证明。\r\n流程图：\r\n\r\nimage-20211220162748498\r\n\r\nRSA数字签名算法\r\n简单的数字签名算法\r\n\r\nimage-20211220162521807\r\n\r\n将 \\(m\\) 和 \\(c\\) 一起发送, 作为签名 \\((m, c)\\) 。 由于与 \\(e_{A}\\) 相对应的 \\(d_{A}\\) 是A所独有, 因此 \\(c\\) 一定来自 \\(A\\), 又因为 \\(e_{A}\\) 是公开的, 则 \\(m\\) 不能保密。\r\nRSA签名与加密的结合\r\n\r\n当 \\(\\mathrm{N}_{\\mathrm{A}}&lt;\\mathrm{N}_{\\mathrm{B}}\\) 时, 先签名, 后加密\r\n\r\n用户 \\(\\mathrm{A}\\) 先用自己的保密密钥 \\(d_{A}\\) 对消息 \\(m\\) 进行签名, 得到: \\(y=m^{d_{4}} \\bmod N_{A}\\)\r\n\\(\\mathrm{A}\\) 再用用户 \\(\\mathbf{B}\\) 的公开密钥 \\(e_{B}\\) 对签名 \\(y\\) 进行加密,得到: \\(c=y^{e_{B}} \\bmod N_{B}\\) 然后将既签名, 又加密了的 \\(c\\) 发送给用户 \\(\\mathbf{B}\\);\r\n\\(\\mathbf{B}\\)收到 \\(c\\) 后, 先进行变换: \\(y=c^{d_{B}} \\bmod N_{B}\\)\r\n再用A的公开密钥作变换: \\(m=y^{e_{A}} \\bmod N_{A}\\)。\r\n从而验证签名来自 \\(\\mathrm{A}\\)。\r\n\r\n当 \\(\\mathrm{N}_{\\mathrm{A}}&gt;\\mathrm{N}_{\\mathrm{B}}\\) 时, 先加密，后签名\r\n\r\n用户A先用B的公开密钥 \\(e_{B}\\) 对消息 \\(m\\) 进行加密, 得到: \\(y=m^{e_{B}} \\bmod N_{B}\\)\r\n\\(\\mathrm{A}\\) 再用自己的保密密钥 \\(d_{A}\\) 对 进行签名, 得到: \\(c=y^{d_A} \\bmod N_{A}\\) 然后将既签名, 又加密了的 \\(c\\) 发送给用户 \\(\\mathbf{B}\\);\r\n\\(\\mathbf{B}\\)收到 \\(c\\) 后, 先进行变换: \\(y=c^{e_{A}} \\bmod N_{A}\\)\r\n再用自己的保密密钥作变换:\\(m=y^{d_{s}} \\bmod N_{B}\\)\r\n从而验证签名来自\\(\\mathrm{A}\\)。\r\ntips:存在着被中间攻击者使用公钥进行验证然后再使用自己的私钥进行签名的风险。\r\n\r\n解决方案：系统中的每个用户采用两个模数，一个用于加密，一个用于签名。并且保证所有用户的签名模数均小于其他用户的加密模数。\r\n\r\nRSA数字签名的缺点：\r\n\r\n利用用户 \\(\\mathbf{A}\\) 的签名识别密钥 \\(k_{e}\\), 任意给定 \\(y\\), 任 何人都可计算出: \\(x=y^{k e} \\bmod n\\), 因而可以伪造对消息 \\(x\\) 的 签名 \\(y\\) 。 注意: 文件 \\(x\\) 的具体值, 伪造者无法控制。虽然可 伪造（文件一签名）对, 但这里的文件 \\(x\\) 可能是毫无意义的随机数。第三者无法伪造出想要的文件的签名。\r\n如果用户 \\(\\mathbf{A}\\) 对文件 \\(x_{1}\\) 和文件 \\(x_{2}\\) 的签名分别为 \\(y_{1}\\) 和 \\(y_{2}\\), 由于 \\(\\left(x_{1} x_{2}\\right)^{d} \\bmod n=\\left[\\left(x_{1}{ }^{d} \\bmod n\\right)\\left(x_{2}{ }^{d} \\operatorname{modn}\\right)\\right] \\bmod n\\) 故任何第三方知道 \\(x_{1}, x_{2}, y_{1}, y_{2}\\), 都可伪造出用户 \\(\\mathrm{A}\\) 对 文件 \\(x_{1} x_{2} \\operatorname{modn}\\) 的签名 \\(y_{1} y_{2} \\operatorname{modn}\\) 。 注意: 文件 \\(x_{1} x_{2} \\bmod n\\) 的具体值伪造者无法控制。\r\n对长文件的签名，若采取电码本方式逐块签名, 则\r\n\r\n签名变长, 签名速度慢\r\n会遭遇替换攻击（重新组合和替换文件块）\r\n\r\n解决方案：先将文件压缩成一个摘要, 再对摘要签名。\r\n\r\nDSA数字签名算法\r\nDSA==安全性==基于有限域上的离散对数问题\r\n==参数选取：==\r\n（1）选取大素数 \\(p ; 2^{\\mathrm{L}-1}&lt;p&lt;2^{\\mathrm{L}}, \\mathrm{L}\\) 至少为 512 比特, 并且是 64 的倍数; DSS推荐L \\(\\leq 512+64 \\times 8=1024\\) （2）选取素数 \\(q ;(q\\) 是 \\(p-1\\) 的一个 160 比特的素数因子) （3）选取整数 \\(g=\\boldsymbol{h}^{(p-1) / q} \\bmod p ;(g&gt;1\\); 其中 \\(1&lt;h&lt;p-1)\\) （4）随机选取整数 \\(x, \\quad(0&lt;x&lt;q)\\) （5）计算 \\(y=g^{x} \\bmod p\\); 公开参数: \\(p, q, g\\); 公开密钥: \\(y\\); 保密密钥: \\(x\\)\r\n==签名过程：==\r\n设用户 \\(\\mathrm{A}\\) 要对消息 \\(m\\) 进行签名, 则:\r\n\r\n\\(\\mathrm{A}\\)秘密选取一个小于 \\(q\\) 的随机数 \\(k\\);\r\n\\(\\mathrm{A}\\)计算:\r\n\r\n\\[\r\n\\left\\{\\begin{array}{c}r=\\left(g^{k} \\bmod p\\right) \\bmod q \\\\ s=k^{-1}(H(m)+x r) \\bmod q\\end{array}\\right.\r\n\\]\r\n$ 则其签名为 $\\((\\boldsymbol{r}, \\boldsymbol{s})\\) 注: \\(\\mathrm{H}(m)\\) 是算法选定的Hash函数, 可将任意长的输入变换为定长的输出; \\(k^{-1}\\) 是 \\(k \\bmod q\\) 的逆元。\r\n==验证过程==\r\n\r\n收方\\(\\mathbf{B}\\)计算 \\[\r\n\\begin{aligned}\r\n&amp;\\left\\{\\begin{array}{c}\r\nw=s^{-1} \\bmod q \\\\\r\nu_{1}=H(m) w \\bmod q \\\\\r\nu_{2}=r w \\bmod q\r\n\\end{array}\\right.\\\\\r\nv=&amp;\\left(\\left(g^{u_{1}} \\times y^{u_{2}}\\right) \\bmod p\\right) \\bmod q\r\n\\end{aligned}\r\n\\]\r\n比较\\(v=r\\)。\r\n\r\ntips:消息\\(m\\)不保密，可以铭传，验证签名时使用。\r\n==ECDSA数字签名算法==\r\n参数选取\r\n\r\n构迼有限域 \\(F\\);\r\n生成域 \\(F\\) 上的椭圆曲线 \\(E\\);\r\n取椭圆曲线中的一个点 \\(P\\), 要求点 \\(P\\) 要有大 素数的阶 \\(q\\);\r\n选取一个整数 \\(d\\), 计算 \\(Q=d P\\);\r\n\r\n公开参数: \\(F, E, P ;\\) 公开密钥: \\(Q ;\\) 保密密钥: \\(d\\)\r\n签名过程\r\n设用户 A要对消息 \\(m\\) 进行签名, 则：\r\n\r\n\\(\\mathrm{A}\\) 秘密选取一个小于 \\(q\\) 的随机数 \\(k\\);\r\n\\(\\mathrm{A}\\)计算:\r\n\\(k P=(u, v)\\) \\(r=u \\bmod q\\) \\(s=k^{-1}(H(m)+r d) \\bmod q\\) 则其签名为 \\((r, s)\\)\r\n\r\n验证过程\r\n\r\n收方\\(\\mathbf{B}\\)计算 \\[\r\n\\left\\{\\begin{array}{c}\r\nw=s^{-1} \\bmod q \\\\\r\nu_{1}=H(m) w \\bmod q \\\\\r\nu_{2}=r w \\bmod q\r\n\\end{array}\\right.\r\n\\]\r\n如果 \\((u, v)=u_{1} P+u_{2} Q\\)。\r\n\r\n==对于上述的验证算法，RSA、DSA、ECDSA不会去考过程但是会考计算。因此，需要我们自己知道如何进行公式的计算。老师特别强调了以下DSA中g是需要我们自己进行求解的==\r\nHash函数\r\nHash函数的性质与应用\r\n\r\n==Hash函数的定义==：又称散列算法、散列函数，是一种从任何一种数据中创建小的数字“指纹”的方法。 散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。\r\n==特性==：\r\n\r\n输入长度可变：对任何长度的输入\\(x\\)都适用\r\n输出长度固定：对任何长度的输入\\(x\\)，输出\\(z\\)都是固定长度\r\n效率：计算复杂度低\r\n抗原像攻击（单向性）：对于给定输出\\(y\\)，不可能找到对应的输入\\(x\\)\r\n抗第二原像攻击（抗弱碰撞性）：对于给定的\\(x_1\\)，找到满足\\(h(x_1)=h(x_2)\\)的\\(x_2\\)是不可能的\r\n抗碰撞攻击（抗强碰撞性）：找到满足\\(h(x_1)=h(x_2 )\\)的偶对\\(x_1=x_2\\)。\r\n\r\ntips:满足了抗强碰撞性一定满足抗弱碰撞性，但反之不成立。\r\n==Hash函数分类==：\r\n\r\n不带密钥的Hash函数\r\n带密钥的Hash函数\r\n\r\nHash函数用途：\r\n\r\n数据完整性检验\r\n用于数字签名\r\n\r\nimage-20211219214020289\r\n\r\n密钥推导\r\n伪随机数生成\r\n\r\n\r\n==对Hash函数的碰撞攻击方法==\r\n目的: 找到两个不同的报文\\(m_1\\)和\\(m_2\\)使得\\(H(m_1)=H(m_2)\\)\r\nStep1 ：随机选取N个不同的报文\\(m_1,m_2,..., m_N\\)；\r\nStep2：计算这N个报文的Hash值,得到集合\\(S=\\{(m_k, H(m_k)): k = 1,2,..., N\\}\\)；\r\nStep3：根据\\(H(m_k)\\)的大小，对集合\\(S\\)利用快速排序算法重新排序。\r\n在排序过程中，如果找到了使\\(H(m_k)= H(m_t)\\) 的两个不同消息\\(m_k\\)和\\(m_t\\)，就将\\((m_k,m_t)\\)作为结果输出，算法终止；如果找不到，就报告碰撞攻击失败，算法终止。\r\n算法所需的存储量: 表\\(S\\)的规模\\(O(N)\\)\r\n算法所需的计算量: \\(N + |N|log_2|N| = O(N)\\)\r\n==成功率分析==（考试可能进行涉及）\r\n设Hash值为\\(n\\)比特且\\(N\\)远小于\\(2n\\),则碰撞攻击的成功率近似为： \\[\r\n1-e^{-\\frac{N^{2}}{2^{n+1}}}\r\n\\] 方法论：\r\n\r\n使用了对立事件进行转化。碰撞成功是至少找出一对报文，它们对应的Hash值是一样的。那么先求出其对立事件，任何一对报文对应的Hash值都是不一样的。\r\n使用了条件概率公式对其进行计算。首先是对于两个报文，其对应的Hash值不一样。然后在两个报文不等的前提上计算三个报文对应的Hash值不一样。\r\n公式的灵活运用： \\[\r\n\\prod_{i=1}^{N-1}\\left(1-\\frac{i}{2^{n}}\\right) \\approx \\prod_{i=1}^{N-1} e^{\\frac{i}{2^{n}}}=e^{\\frac{-N(N-1)}{2^{n+1}}} \\approx e^{\\frac{-N^{2}}{2^{n+1}}}\r\n\\]\r\n\r\n能够对抗碰撞攻击的Hash函数的==安全界限==：假设能对抗穷举攻击的密钥长度的安全界限为\\(n\\)比特，则对抗碰撞攻击的Hash算法的Hash值的比特数量的安全界限应为\\(2n\\)。\r\n基于分组密码算法的Hash函数\r\nMD强化技术：将消息\\(M = (M_1,M_2,…,M_n)\\)的最后一个分组\\(M_n\\)设置为原始消息的长度，这个过程称为MD强化。\r\n基于分组密码设计Hash函数的一般方法：消息\\(M = (M_1,M_2,…,M_n)\\)，\\(H_0\\)是初始值，\\(H_i=E(H_{i-1},M_i), i=1,2,…,n\\)。最后得到的\\(H_n\\)是消息\\(M\\)的Hash值。\r\n示例： \\[\r\n\\begin{gathered}\r\nH_{i}=E_{H_{i-1}}\\left(\\mathrm{M}_{i}\\right) \\oplus \\mathrm{M}_{i} \\\\\r\nH_{i}=E_{H_{i-1}}\\left(\\mathrm{M}_{i} \\oplus H_{i-1}\\right) \\oplus \\mathrm{M}_{i} \\oplus H_{i-1} \\\\\r\nH_{i}=E_{H_{i-1}}\\left(\\mathrm{M}_{i}\\right) \\oplus \\mathrm{M}_{i} \\oplus H_{i-1} \\\\\r\nH_{i}=E_{H_{i-1}}\\left(\\mathrm{M}_{i} \\oplus H_{i-1}\\right) \\oplus \\mathrm{M}_{i}\r\n\\end{gathered}\r\n\\]\r\nMD5 Hash函数（需要进行关注）\r\n==MD5的特点==：对任意长度的输入，产生128位的输出；且其安全性不依赖于任何假设，适合高速实现。\r\n==MD5算法==的一个主循环一次可处理512比特数据分组。执行主循环\\(t\\)次最后输出为128比特。（\\(t\\)等于填充后消息长度除以512）\r\n\r\n==初始化处理==：经过初始化处理后的消息长度是512的整数倍（==可能会出一个计算题==）\r\n在原始消息的二进制表示之后先填入一个1，在最低位64比特填入原始消息长度的二进制表示，中间全部补0，使填充后的消息长度恰好是512的整数倍。如果消息长度大于\\(2^{64}\\)，则在最低的64比特位填入消息长度取模\\(2^{64}\\)后的二进制表示。\r\n\r\nimage-20211219221553394\r\n\r\n经过初始化处理后的消息\\(x\\)被分成\\(t\\)个512比特的消息块\\(x_0,x_1, …,x_{t-1}\\)。将每个消息块\\(x_i（i=0,1,2,…,t-1）\\)划分成16个32比特的子块，记为\\(x_i=\\{M_{[16i]}、M_{[16i+1]}、…、M_{[16i+15]}\\}.\\)\r\n使用4个32比特的初始向量，分别为A、B、C、D。又称为链接值\r\n==基本函数==：（只需要知道存在四个基本函数，不需要知道基本函数的具体）\r\n算法使用的四个基本函数： \\[\r\n\\begin{aligned}\r\n&amp;F(X, Y, Z)=(X \\wedge Y) \\vee(\\bar{X} \\wedge Z) \\\\\r\n&amp;G(X, Y, Z)=(X \\wedge Z) \\vee(Y \\wedge \\bar{Z}) \\\\\r\n&amp;H(X, Y, Z)=X \\oplus Y \\oplus Z \\\\\r\n&amp;I(X, Y, Z)=Y \\oplus(X \\vee \\bar{Z})\r\n\\end{aligned}\r\n\\] \\(X+Y\\)表示模232的加法运算\r\n具体过程：（不会进行具体的计算，但是流程应该知道，比如知道迭代多少次）\r\nStep1 执行\\(\\mathrm{X}[0] \\leftarrow \\mathrm{M}[16 \\mathrm{i}], \\mathrm{X}[1] \\leftarrow \\mathrm{M}[16 \\mathrm{i}+1], \\ldots, \\mathrm{X}[15] \\leftarrow \\mathrm{M}[16 \\mathrm{i}+15]\\)\r\nStep2 执行: \\(A A \\leftarrow A, B B \\leftarrow B, C C \\leftarrow C, D D \\leftarrow D\\)\r\nStep3 执行: \\((\\mathrm{A}, \\mathrm{B}, \\mathrm{C},\\mathrm{D}) \\leftarrow \\operatorname{Round1}(\\mathrm{A}, \\mathrm{B}, \\mathrm{C}, \\mathrm{D}, \\mathrm{X}[0], \\ldots, \\mathrm{X}[15])\\)\r\nStep4 执行: \\((\\mathrm{A}, \\mathrm{B}, \\mathrm{C},\\mathrm{D}) \\leftarrow \\operatorname{Round2}(\\mathrm{A}, \\mathrm{B}, \\mathrm{C}, \\mathrm{D}, \\mathrm{X}[0], \\ldots, \\mathrm{X}[15])\\)\r\nStep5 执行: \\((\\mathrm{A}, \\mathrm{B}, \\mathrm{C},\\mathrm{D}) \\leftarrow \\operatorname{Round3}(\\mathrm{A}, \\mathrm{B}, \\mathrm{C}, \\mathrm{D}, \\mathrm{X}[0], \\ldots, \\mathrm{X}[15])\\)\r\nStep6 执行:\\((\\mathrm{A}, \\mathrm{B}, \\mathrm{C},\\mathrm{D}) \\leftarrow \\operatorname{Round4}(\\mathrm{A}, \\mathrm{B}, \\mathrm{C}, \\mathrm{D}, \\mathrm{X}[0], \\ldots, \\mathrm{X}[15])\\)\r\nStep7 执行: \\((\\mathrm{A}, \\mathrm{B}, \\mathrm{C}, \\mathrm{D}) \\leftarrow(\\mathrm{A}, \\mathrm{B}, \\mathrm{C}, \\mathrm{D})+(\\mathrm{AA}, \\mathrm{BB}, \\mathrm{CC}, \\mathrm{DD})\\)\r\n最后是将A、B、C、D进行拼接，形成MD5最后的结果。128=32*4。\r\nMD5主循环：\r\n\r\nimage-20211220094004821\r\n\r\nround结构：\r\n\r\nimage-20211220103532831\r\n\r\n其他三个分别使用另外三个基本函数。s是\r\n\r\nimage-20211220104319171\r\n\r\nt的计算方法如下：\\(2^{32}{*} a b s(\\sin (\\mathrm{i}))\\)\r\n\r\n基于Hash函数的消息认证码\r\n\r\nimage-20211220104642211\r\n\r\n安全要求：\r\n\r\n未知密钥时不能构造消息-认证码的一个匹配对;（单向性）\r\n未知密钥时不能将一个消息-认证码的匹配对修改为另一个消息-认证码的匹配对。（弱无碰撞性）\r\n\r\n基于Hash函数的的HMAC消息认证码\r\n对于密钥k和Hash函数Hash，按如下方式计算消息m的消息认证码MAC：\\(HMAC(m) = Hash_{k_2}(Hash_{k_1}(m))\\)\r\n\r\nimage-20211220105018727\r\n\r\n人工智能安全\r\n\r\nAl应具有的==安全要求==：\r\n\r\n可靠：无污染的训练和测试过程。\r\n稳定：模型应具有足够的鲁棒性以处理有噪声的输入\r\n隐私：用户看不到有关该模型的所有信息\r\n\r\n主要攻击==手段分类==：\r\n\r\n==数据中毒==\r\n\r\n定义：攻击者通过将中毒的样本引入训练/验证/测试集造成的因果攻击\r\n原理：错误的或是中毒的样本会使分类器学到错误的特征，从而改变了分类器模型\r\n错误特征的不同表现：\r\n\r\n传统分类器：如支持向量机，会因为中毒的样本导致分类器分类错误，产生性能下降，因此适合实现可用性攻击\r\n\r\nimage-20211225135258273\r\n\r\n深度神经网路：其具有较强的复杂性，可以容忍一定的中毒样本，但会对其进行记忆，因此可以完成==后门攻击==。（针对性的攻击）\r\n\r\nimage-20211225135231290\r\n\r\n\r\n\r\n对抗样本\r\n\r\n定义：指攻击者通过输入经过不为人所察觉的扰动后的样本，使得分类模型决策发生本不应该发生的变化。\r\n原理：在样本上施加一定的扰动，这些扰动是根据目标模型精心设计的。这种攻击属于一种灰盒或白盒攻击。\r\n\r\n逆向工程\r\n\r\n定义：通过查询一个分类器，以了解它的决策规则或它的训练集（即对数据隐私的攻击）。\r\n不同目标：\r\n\r\n模型推断攻击：构建与目标模型决策相似的模仿模型\r\n\r\nimage-20211225140903864\r\n\r\n模型重构攻击：获取训练集隐私的攻击，重构训练集中的样本\r\n数据推测攻击：获取训练集隐私，判断某个样本是否属于训练集\r\n\r\n\r\n对抗样本攻击与后门攻击的异同：\r\n\r\nimage-20211225135918971\r\n\r\n\r\n主要攻击目标分类（了解即可）\r\n\r\n因果攻击\r\n\r\n有针对性的攻击\r\n无差别攻击\r\n可用性攻击\r\n\r\n探索性攻击：不更改学习模型，更改学习模型的参数等信息\r\n\r\n==AI攻击总结==\r\n\r\n\r\n\r\n\r\n数据中毒攻击\r\n对抗样本攻击(逃逸攻击)\r\n逆向工程攻击\r\n\r\n\r\n\r\n\r\n阶段\r\n训练阶段\r\n测试阶段\r\n测试阶段\r\n\r\n\r\n目标\r\n因果攻击\r\n因果攻击（有针对性攻击、无差别攻击为主）\r\n探索性攻击\r\n\r\n\r\n知识\r\n都可以\r\n白盒、灰盒为主\r\n黑盒\r\n\r\n\r\nCIA\r\n破坏完整性、可用性\r\n破坏完整性、可用性\r\n破坏机密性\r\n\r\n\r\n补充\r\n要求攻击者有破坏训练集的能力\r\n黑盒情况下需要探索性攻击作为补充\r\n通常作为对抗样本攻击的第一步\r\n\r\n\r\n\r\n数据中毒防御\r\n\r\n方法：训练集消毒、如特征选择或降维，去除异常样本\r\n不足：\r\n\r\n攻击者具有防御知识，可以更好地设计数据中毒攻击，规避防御并降低分类器准确性\r\n如果没有攻击者，分类准确率会降低\r\n\r\n\r\n对抗样本防御\r\n\r\n在学习期间使用经过修改的训练集，或者在测试期间使用经过修改的输入\r\n修改网络，如增加网络层数、更改激活功能\r\n在过难分辨的示例进行分类时，使用外部模型作为补充\r\n\r\n逆向工程防御\r\n\r\n模型提供者减少或者修改输出信息，提高攻击的攻击难度\r\n\r\nAI助力安全（前面时AI面临的安全问题）\r\n\r\n检测恶意软件\r\n认证\r\n设计加密算法\r\n\r\n\r\n","categories":["Subject notebook"],"tags":["Subject notebook"]},{"title":"云计算技术作业1","url":"/2022/03/11/2022-03-11-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF%E4%BD%9C%E4%B8%9A1/","content":"本部分是云计算的作业1部分。在本节课中学习了云使能技术。了解了它的主要技术并且这些技术的相关组件以及一些特点。通过对这些的了解并且复习完成了下面的作业。\r\n\r\n作业1\r\n\r\n\r\n\r\n班级\r\n数据科学与大数据技术班\r\n\r\n\r\n\r\n\r\n学号\r\n201900130140\r\n\r\n\r\n姓名\r\n李焱\r\n\r\n\r\n\r\n\r\n云使能技术主要包括哪些技术组件？简要说明其关键特征。\r\n答：云技术主要包括以下六个组件：\r\n\r\n宽带网络和Internet架构：所有的云必须连接到网络。因此，网络互联是云计算的固有依赖技术。互联网或者Internet允许远程供给IT资源，并直接支持无处不在的网络接入。云用户可以通过Internet访问或者通过LAN中私有和专用的网络链接来接入云；\r\n数据中心技术：这是一种特殊的IT基础设施，用于集中放置IT资源；数据中心包含了物理和虚拟的IT资源，具有虚拟化的特点；数据中心以标准化商用软件为基础，用模块化架构进行设计；并且具有自动化、远程操作与管理、高可用性等特点；\r\n虚拟化技术：是将物理IT资源转换为虚拟IT资源的过程，虚拟服务器使用自己的客户操作系统，独立于创建虚拟服务器的操作系统，具有硬件无关性；允许不同的虚拟服务器共享同一个物理服务器，具有服务器整合的特点；在虚拟服务器上运行的客户操作系统和应用软件，都不会感知到虚拟化的过程；虚拟化技术是涵盖整个IT架构的，包括资源、网络、应用和桌面在内的全系统虚拟化，实现IT架构的动态化，实现资源集中管理，使应用能够动态地使用虚拟资源和物理资源，提高系统适应需求和环境的能力。\r\nWeb技术：WWW是由通过Internet访问的互联IT资源构成的系统，具有普遍性、服务开发的简单易用以及Web应用的高可访问性。其两个基本组件是Web浏览器客户端和Web服务器；\r\n多租户技术：其目的是使得多个用户在逻辑上同时访问同一个应用。具有应用隔离、数据安全、可恢复性、应用升级、可扩展性、使用计费、数据层隔离等特点；\r\n服务技术：基于Web的服务(如Web服务和REST服务)依靠非专有通信和技术接口定义来建立基于Web技术的标准通信框架，服务代理提供事件驱动运行时处理，适用于云中大量的功能。许多代理都自动部署在操作系统和基于云的产品中，服务中间件(如ESB和业务流程平台)可以在云上部署。\r\n\r\n列举至少三种虚拟化软件，并概括其特点。\r\n答：在这里主要列举四种虚拟化软件：VMware ESXi、KVM、Xenserver、Docker。\r\n\r\nVMware ESXi重点于服务器虚拟化、技术较成熟、功能多、支持虚机系统多；\r\nKVM是键盘(Keyboard)、显示器(Video)、鼠标(Mouse)的缩写。KVM技术具有系统和网络的集中管理、系统的高可管理性、系统管理员的工作效率高、机房的面积小、网络工程和服务器系统的总体拥有成本低、健康环保以及多主机切换系统。\r\nXenserver重点在于桌面虚拟化，性价比高，网络性能好，适用于快速与大规模部署，支持系统多，但做桌面能发布出来的只有MS系统；\r\nDocker技术使用Linux 内核和内核功能（例如 Cgroups 和 namespaces）来分隔进程，以便各进程相互独立运行。这种独立性正是采用容器的目的所在；它可以独立运行多种进程、多个应用，更加充分地发挥基础设施的作用，同时保持各个独立系统的安全性。具有模块化、层和镜像版本控制、回滚和快速部署等特点。\r\n\r\n\r\n","categories":["云计算作业"],"tags":["云技术技术和实践"]},{"title":"Data visualization","url":"/2022/03/08/Final/","content":"本文件记录了数据可视化的大作业总结，介绍了可视化效果。并且附上了可视化图片以及小组分工\r\n\r\n\r\n \r\n\r\n\r\n数据可视化大作业 Project\r\n\r\n\r\n--游乐园人员轨迹探索性分析\r\n\r\nOverview\r\nTeaser image\r\n\r\nimage-20211221011241440\r\n\r\n\r\n\r\nFigure 1:Map-based personal trajectory visualization\r\n\r\n\r\n\r\nimage-20211221011306378\r\n\r\n\r\n\r\nFigure 2:Feature representation of groups based on radar chart and PCP\r\n\r\n\r\n\r\nimage-20211221011428434\r\n\r\n\r\n\r\nFigure 3:Group visualization combined with map and heat map\r\n\r\n\r\n\r\nimage-20211221011512568\r\n\r\n\r\n\r\nFigure 4:Anomaly detection based on three-dimensional scatter plot\r\n\r\n\r\n\r\nimage-20211221011540235\r\n\r\n\r\n\r\nFigure 5:Visual link of spatio-temporal data heat map and histogram\r\n\r\n\r\nSummary\r\n​ Through a huge park visitor data set, based on the data clustering, low-dimensional embedding and outlier detection, the effects of tourist trajectory visualization, trajectory clustering, pattern recognition, and outlier analysis are performed. We use d3.js to build a Web visualization system to visualize a large spatiotemporal series data set. In this visualization model, data collation, tourist trajectory feature analysis, attractions network node analysis and interactive visualization are realized, and a specific relationship clustering is performed for tourists. Through this system, users can also understand the outliers in the tour trajectory and capture some criminal information.\r\nData\r\n​ The datasets provided were .csv files for Friday, Saturday, and Sunday, containing a date-time stamp, a visitor ID, a tag as to whether the record referred to a movement within the park grid or a check-in to an amusement park ride, and a grid location (x,y coordinates). And The scale of the data is 25 million.\r\n​ For this data, the language for data preprocessing is Python, and the tools used are Spyder and Jupyter Notebook. First, the data is processed to eliminate null values and error values, and some points where type should be equal to check-in are restored, and then according to the timing relationship, data is extracted from different id to obtain dynamic data. By increasing the time granularity of the dynamic data, a static data is obtained, and the time unit is min. Calculate the travel time between two nodes for each visitor. Then calculate the information of different dimensions and use the k-means method to cluster. Then use PCA(Principal components analysis) for data dimensionality reduction, which is convenient for visual presentation. And by continuously performing the 3σ principle and clustering on the data nodes, some outliers and a perfect clustering effect are ly iteratively obtained.\r\nGoals and Tasks\r\n​ A map-based interactive visualization interface is implemented for all data. Users can interactively realize static and dynamic queries of all park visitors by day and id. Among them, two colors are used to distinguish the type of different data items. Considering the user's spatiotemporal data and the user's visiting points, the groups are clustered using hierarchical clustering. The groups are divided into 12 groups, so as to obtain a visualized optimization interface, which can query the trajectory of tourists by group. Make a static heat map to visualize the number of people corresponding to each rides every day, understand the distribution of popular attractions, and further explore the reasons for the popularity. Color distinguishes different types of scenic spots, and uses a time series axis as an attribute for visualization. And can allow users to choose the date. The granularity can even be reduced to make the distinction more detailed. Use the parallel coordinate system to analyze the mutual influence of various relationships in a group. Use different colors to make a group first. Use different axes to represent the attributes of these groups. Through the analysis of the parallel coordinate axis, understand the attribute relationship between each group. And you can drag and move between axes to analyze the relationship between different attributes. Perform low-dimensional embedding on the data and then visualize interactive presentation. For one or one type of data, click on another data to draw the trajectory.\r\nVisualization\r\n​ First, use the HTML front-end language to write the navigation bar, and the user clicks on the item in the navigation bar to jump to the page. The code is implemented as follows:\r\n&lt;div class=&quot;top&quot;&gt;    &lt;div style=&quot;text-align: center;&quot;&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a href=&quot;index.html&quot;&gt;&lt;b&gt;Trace&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;group.html&quot;&gt;&lt;b&gt;Group&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;heat-map.html&quot;&gt;&lt;b&gt;Heat-Map&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;3D_scatter.html&quot;&gt;&lt;b&gt;3D_Scatter&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;matrix.html&quot;&gt;&lt;b&gt;Matrix&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;\r\n​ The first view is a map-based trajectory visualization. It allows the user to manually enter the visitor id in the input box or select the visitor id from the drop-down list on the corresponding day to query the user trajectory. First, perform gray-scale conversion processing on the provided pictures by calling the PIL library of the programming language Python, which is convenient for visual effects. Then cut this picture into a grid and divide it into a 100*100 grid. The visual presentation effect is to divide the points of visitors at any moment into grids. The user enters the id of the visitor, and the visualization system detects the id by traversing the existing .csv file to determine whether the id exists on this day, and then select the corresponding .csv file from the folder through the id. If it is a static trajectory query, directly visualize all the data, the color of the dot indicates the type of the point, and the size indicates the dwell time. In order to study which scenic spots the tourists have stayed at and the stay time of each grid point, as shown in Figure 6.  \r\n\r\nimage-20211221023759801\r\n\r\n\r\n\r\nFigure 6:Static trajectory visualization\r\n\r\n\r\n​ If it is a dynamic trajectory presentation, the visual view will visualize the data in chronological order and allow the user to pause the operation. In addition, the interface will also present corresponding dynamic time changes, as shown in Figure 7  and Figure 8.  \r\n\r\nimage-20211221024016036\r\n\r\n\r\n\r\nFigure 7:Dynamic trajectory visualization\r\n\r\n\r\n \r\n\r\nimage-20211221024129343\r\n\r\n\r\n\r\nFigure 8:Dynamic trajectory visualization\r\n\r\n\r\n​ Then visualize the clustered data. All tourists in the three days are divided into 12 groups according to 14 dimensions of check-in amusement equipment type, average speed and stay time. The radar chart (Figure 9) and the parallel coordinate system (Figure 10) are used in this interface. The radar chart allows users to use different scales for the axes, and to name the axes with special meanings. And users are allowed to choose different types of groups. It is convenient for users to discover the characteristics of each group. Use the parallel coordinate system for the same visual presentation, but in the parallel coordinate system, you can see the user's specific value in this dimension. And the operation of brush and axis drag has been added. The brush allows users to select specific groups for correlation analysis. Axis drag allows users to perform correlation analysis on different features. And the two visualization components use the same legend. \r\n\r\nimage-20211221143737680\r\n\r\n\r\n\r\nFigure 9:Cluster visualization based on radar chart\r\n\r\n\r\n \r\n\r\nimage-20211221144127723\r\n\r\n\r\n\r\nFigure 10:Cluster visualization based on parallel coordinate system\r\n\r\n\r\n​ In the next view, a heat map(Figure 11) is used to visualize the number of people at the corresponding time and scenic spot. First, different types of scenic spots are marked with different colors and presented in order. Then, the time period from 8:00 to 23:00 will be equally divided into 30 segments, each of which is 30 minutes. The user can clearly see the distribution of the number of people at the corresponding time and place. The visual code of color is used to indicate the number of people. The darker the color, the more the number of people. And realize the one-way link between the views. When you click on a small block in the heat map, a bar chart(Figure 12) will appear on the right, which represents the number of people corresponding to different groups in this place during this period of time.  \r\n\r\nimage-20211221150207457\r\n\r\n\r\n\r\nFigure 11:spatiotemporal distribution of the number of people based on the heat map\r\n\r\n\r\n \r\n\r\nimage-20211221150637593\r\n\r\n\r\n\r\nFigure 12:Visual link of spatio-temporal data heat map and bar chart\r\n\r\n\r\n​ Next, explore and analyze the movement patterns of different groups. An innovative view method is used here to visualize the heat map and the map(Figure 13). However, the distribution of the grid in the heat map becomes the actual movement trajectory. As described above, the visual code of color is used in the heat map to indicate the number of people, and the darker the color, the greater the number of people. The user can select the day by selecting the button, and then enter the group id in the input box, the user can view the next time period through enter, and return to the previous time period using esc. Among them, the movement of each person in each time period has been calculated through Python, and a variable is used to represent the time in d3.js. Every time draw is called, the image will be redrawn. \r\n\r\nimage-20211221152748831\r\n\r\n\r\n\r\nFigure 13:Group visualization combined with map and heat map\r\n\r\n\r\n​ ly, a three-dimensional scatter plot(Figure 14) is used to draw outliers. First, use the PCA method to reduce the dimensionality of the clustered data set to obtain a three-dimensional data set with labels. Then save the data in a folder and use d3.js to access it. Since the data after dimensionality reduction has negative numbers, it is not conducive to visualization. Therefore, subtract the minimum value of each dimension to get a non-negative data set. In the scatter chart, a different color is used for different groups, and zooming and axis rotation operations are implemented for the view, which is convenient for users to find abnormal data. And when the user selects a data point, the corresponding axis will form a line with it, which is convenient for the user to compare and observe the value.  \r\n\r\nimage-20211221153836223\r\n\r\n\r\n\r\nFigure 14:Anomaly detection based on three-dimensional scatter plot\r\n\r\n\r\nReflection\r\n​ First understand the data set, and perform a preliminary data preprocessing operation. Then a visual propsal was proposed for this. In this proposal, the general direction of visualization and the visualization implementation plan are introduced. In the subsequent time, through more complex processing operations on the data, such as k-means clustering, PCA dimensionality reduction, and iterative optimization of anomaly detection, and driven by the data, we constantly improve our visualization scheme. Through further familiarity with d3.js and some visual design templates, and according to the proposed milestone, the visual view is continuously realized. In the initial proposal, we first asked for a group of data to visualize the trajectory, but ly found that using a heat map has a better presentation effect. In the process of visual design, we want to achieve a two-way link between the radar chart and the parallel coordinate system, but referring to websites such as Stack Overflow, we only know how to link the same view component, such as two pie charts. Therefore, the visual presentation of two-way links was ly abandoned. If you do this project again, you will process the data earlier and try to use different clustering and dimensionality reduction methods. And try some new view components.\r\nTeam Assessment\r\n\r\n\r\n\r\n成员\r\n工作\r\n\r\n\r\n\r\n\r\n李焱\r\n数据预处理、可视化界面初步设计、文档编写、可视化系统的实现--三维散点图、系统的优化\r\n\r\n\r\n于腾博\r\n数据预处理、文档编写、可视化系统的实现--视图之间的链接、系统的优化\r\n\r\n\r\n钟秋愉\r\n可视化系统的实现--平行坐标系、热力图、柱状图、单向链接、文档编写\r\n\r\n\r\n张菊华\r\n可视化系统的实现--雷达图、轨迹图、热力图、三维散点图、文档编写\r\n\r\n\r\n\r\n","categories":["Subject notebook"],"tags":["Subject notebook"]},{"title":"Hello World","url":"/2022/03/07/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\r\nQuick Start\r\nCreate a new post\r\n$ hexo new &quot;My New Post&quot;\r\nMore info: Writing\r\nRun server\r\n$ hexo server\r\nMore info: Server\r\nGenerate static files\r\n$ hexo generate\r\nMore info: Generating\r\nDeploy to remote sites\r\n$ hexo deploy\r\nMore info: Deployment\r\n","tags":["Introduction"]},{"title":"Navicat生成指定sql文件版本","url":"/2020/10/16/Navicat%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9Asql%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC/","content":"mysql在数据备份时因为mysql版本不同，导致于高版本数据库生成的sql文件，放到低版本数据库中不能执行，在Navicat中生成sql文件时是可以指定版本的，那么就可以解决这个问题\r\n\r\n1.查看要导入数据的mysql版本号\r\nmysql -V #执行该命令可以在不登录的情况下查看mysql版本，注意V一定要大写\r\n2.生成对应版本的sql文件\r\n\r\n选择数据库后找到Navicat的数据传输\r\n\r\n\r\n\r\n指定相应的sql文件版本\r\n\r\n\r\n\r\n完成以上步骤就大工告成了，不过在不同的Navicat版本中会有些不同，我的是12.0的版本\r\n\r\n","categories":["mysql"],"tags":["mysql"]},{"title":"MongDB非关系型数据库","url":"/2020/04/15/mongDB/","content":"MongDB做为一款由 C++编写的非关系型数据库（NoSql）,却有着最接近 SQL型数据库的功能，使用成本比 SQL型数据库低，做为评论系统来使用非常不错\r\n\r\n\r\n一、MongoDB简介\r\n1.文章评论数据分析\r\n\r\n数据量大\r\n写入操作频繁\r\n价值较低（评论数据丢失不会有什么太大影响）\r\n\r\n对于这样的数据，我们更适合使用MongoDB来实现数据的存储，如果使用mysql来存储成本太高\r\n2.什么是MongoDB\r\n\r\nMongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应 用提供可扩展的高性能数据存储解决方案\r\nMongoDB是一个介于关系数据库和非关系数据库之间的产品（自身是非关系型数据库NoSql），是非关系数据库当中功能最丰富，最像关系数据库的\r\n它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型\r\n\r\n3.MongoDB特点\r\nMongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的 查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对 数据建立索引\r\n它的特点是高性能、易部署、易使用，存储数据非常方便，主要功能特性有：\r\n\r\n面向集合存储，易存储对象类型的数据\r\n模式自由\r\n支持动态查询\r\n支持完全索引，包含内部对象\r\n支持查询\r\n支持复制和故障恢复\r\n使用高效的二进制数据存储，包括大型对象（如视频等）\r\n自动处理碎片，以支持云计算层次的扩展性\r\n支持RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言\r\n文件存储格式为BSON（一种JSON的扩展）\r\n\r\n4.MongoDB体系结构\r\n文档(document)、集合(collection)、数据库(database)三部分组成\r\n\r\nMongoDB 的文档（document），相当于关系数据库中的一行记录\r\n多个文档组成一个集合（collection），相当于关系数据库的表\r\n多个集合（collection），逻辑上组织在一起，就是数据库（database）\r\n\r\n\r\n一个 MongoDB 实例支持多个数据库（database）\r\n\r\n对照表：\r\n\r\n\r\n\r\nMongoDB体系结构\r\nMySql体系结构\r\n\r\n\r\n\r\n\r\n数据库(databases)\r\n数据库(databases)\r\n\r\n\r\n集合(collections)\r\n表(table)\r\n\r\n\r\n文档(document)\r\n行(row)\r\n\r\n\r\n\r\n5.MongoDB数据类型\r\n\r\n\r\n\r\n\r\n数据类型\r\n\r\n\r\n描述\r\n\r\n\r\n\r\n\r\n\r\n\r\nString\r\n\r\n\r\n字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。\r\n\r\n\r\n\r\n\r\nInteger\r\n\r\n\r\n整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。\r\n\r\n\r\n\r\n\r\nBoolean\r\n\r\n\r\n布尔值。用于存储布尔值（真/假）。\r\n\r\n\r\n\r\n\r\nDouble\r\n\r\n\r\n双精度浮点值。用于存储浮点值。\r\n\r\n\r\n\r\n\r\nArray\r\n\r\n\r\n用于将数组或列表或多个值存储为一个键。\r\n\r\n\r\n\r\n\r\nTimestamp\r\n\r\n\r\n时间戳。记录文档修改或添加的具体时间。\r\n\r\n\r\n\r\n\r\nObject\r\n\r\n\r\n用于内嵌文档。\r\n\r\n\r\n\r\n\r\nNull\r\n\r\n\r\n用于创建空值。\r\n\r\n\r\n\r\n\r\nDate\r\n\r\n\r\n日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。\r\n\r\n\r\n\r\n\r\nObject ID\r\n\r\n\r\n对象 ID。用于创建文档的 ID。\r\n\r\n\r\n\r\n\r\nBinary Data\r\n\r\n\r\n二进制数据。用于存储二进制数据。\r\n\r\n\r\n\r\n\r\nCode\r\n\r\n\r\n代码类型。用于在文档中存储 JavaScript 代码。\r\n\r\n\r\n\r\n\r\nRegular expression\r\n\r\n\r\n正则表达式类型。用于存储正则表达式。\r\n\r\n\r\n\r\n\r\n特殊说明：\r\n\r\nObjectId\r\nObjectId 类似唯一主键（不指定，会自动生成），可以很快的去生成和排序，包含 12 bytes，含义是：\r\n\r\n前 4 个字节表示创建 unix 时间戳，格林尼治时间 UTC 时间，比北京时间晚了 8 个小时\r\n接下来的 3 个字节是机器标识码\r\n紧接的两个字节由进程 id 组成 PID\r\n最后三个字节是随机数\r\n\r\n\r\nMongoDB 中存储的文档必须有一个 _id 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象\r\n时间戳\r\nBSON 有一个特殊的时间戳类型，与普通的日期类型不相关。时间戳值是一个 64 位的值。其中：\r\n\r\n前32位是一个 time_t 值【与Unix新纪元（1970年1月1日）相差的秒数】\r\n后32位是在某秒中操作的一个递增的序数\r\n\r\n在单个 mongod 实例中，时间戳值通常是唯一的\r\n日期\r\n表示当前距离 Unix新纪元（1970年1月1日）的毫秒数。日期类型是有符号的, 负数表示 1970 年之前的日期\r\n\r\n二、MongoDB常用命令\r\n1.选择和创建数据库\r\n\r\n选择和创建数据库的语法格式：\r\n\r\nuse 数据库名称\r\n\r\n如果数据库存在则选择该数据库，如果数据库不存在则自动创建。以下语句创建commentdb数据库：\r\n\r\nuse commentdb\r\n\r\n查看数据库：\r\n\r\nshow dbs\r\n\r\n查看集合:\r\n\r\n\r\n需要先选择数据库之后，才能查看该数据库的集合\r\n\r\nshow collections\r\n2.插入与查询文档\r\n\r\n选择数据库后，使用集合来对文档进行操作，插入文档语法格式：\r\n\r\ndb.集合名称.insert(数据);\r\n\r\n插入以下测试数据：\r\n\r\ndb.comment.insert(&#123;content:&quot;十次方课程&quot;,userid:&quot;1011&quot;&#125;)\r\n\r\n查询集合的语法格式：\r\n\r\ndb.集合名称.find()\r\n\r\n查询comment集合的所有文档，输入以下命令：\r\n\r\ndb.comment.find()\r\n发现文档会有一个叫_id的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，MongoDB会自动创建，其类型是ObjectID类型。如果我们在插入文档记录时指定该字段也可以，其类型可以是ObjectID类型，也可以是MongoDB支持的任意类型\r\n\r\n输入以下测试语句:\r\ndb.comment.insert(&#123;_id:&quot;1&quot;,content:&quot;到底为啥出错&quot;,userid:&quot;1012&quot;,thumbup:2020&#125;);db.comment.insert(&#123;_id:&quot;2&quot;,content:&quot;加班到半夜&quot;,userid:&quot;1013&quot;,thumbup:1023&#125;);db.comment.insert(&#123;_id:&quot;3&quot;,content:&quot;手机流量超了咋办&quot;,userid:&quot;1013&quot;,thumbup:111&#125;);db.comment.insert(&#123;_id:&quot;4&quot;,content:&quot;坚持就是胜利&quot;,userid:&quot;1014&quot;,thumbup:1223&#125;);\r\n按一定条件来查询，比如查询userid为1013的记录，只要在find()中添加参数即可，参数也是json格式，如下：\r\ndb.comment.find(&#123;userid:&#x27;1013&#x27;&#125;)\r\n只需要返回符合条件的第一条数据，我们可以使用findOne命令来实现：\r\ndb.comment.findOne(&#123;userid:&#x27;1013&#x27;&#125;)\r\n返回指定条数的记录，可以在find方法后调用limit来返回结果，例如：\r\ndb.comment.find().limit(2)\r\n3.修改与删除文档\r\n\r\n修改文档的语法结构：\r\n\r\ndb.集合名称.update(条件,修改后的数据)\r\n\r\n修改_id为1的记录，点赞数为1000，输入以下语句：\r\n\r\ndb.comment.update(&#123;_id:&quot;1&quot;&#125;,&#123;thumbup:1000&#125;)\r\n执行后发现，这条文档除了thumbup字段其它字段都不见了\r\n为了解决这个问题，我们需要使用修改器$set来实现，命令如下：\r\ndb.comment.update(&#123;_id:&quot;2&quot;&#125;,&#123;$set:&#123;thumbup:2000&#125;&#125;)\r\n\r\n删除文档的语法结构：\r\n\r\ndb.集合名称.remove(条件)\r\n\r\n以下语句可以将数据全部删除，慎用~\r\n\r\ndb.comment.remove(&#123;&#125;)\r\n\r\n删除条件可以放到大括号中，例如删除thumbup为1000的数据，输入以下语句：\r\n\r\ndb.comment.remove(&#123;thumbup:1000&#125;)\r\n4.统计条数\r\n\r\n统计记录条件使用count()方法。以下语句统计comment集合的记录数：\r\n\r\ndb.comment.count()\r\n\r\n按条件统计 ，例如统计userid为1013的记录条数：\r\n\r\ndb.comment.count(&#123;userid:&quot;1013&quot;&#125;)\r\n### 5.模糊查询\r\n\r\nMongoDB的模糊查询是通过正则表达式的方式实现的：\r\n\r\n/模糊查询字符串/\r\n\r\n查询评论内容包含“流量”的所有文档，代码如下：\r\n\r\ndb.comment.find(&#123;content:/流量/&#125;)\r\n\r\n查询评论内容中以“加班”开头的，代码如下：\r\n\r\ndb.comment.find(&#123;content:/^加班/&#125;)\r\n### 6.大于 小于 不等于\r\n\r\n&lt;, &lt;=, &gt;, &gt;= 这个操作符也是很常用的，格式如下:\r\n\r\ndb.集合名称.find(&#123; &quot;field&quot; : &#123; $gt: value &#125;&#125;) // 大于: field &gt; valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $lt: value &#125;&#125;) // 小于: field &lt; valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $gte: value &#125;&#125;) // 大于等于: field &gt;= valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $lte: value &#125;&#125;) // 小于等于: field &lt;= valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $ne: value &#125;&#125;) // 不等于: field != value\r\n\r\n查询评论点赞数大于1000的记录：\r\n\r\ndb.comment.find(&#123;thumbup:&#123;$gt:1000&#125;&#125;)\r\n### 7.包含与不包含\r\n\r\n包含使用$in操作符\r\n\r\n\r\n查询评论集合中userid字段包含1013和1014的文档：\r\n\r\ndb.comment.find(&#123;userid:&#123;$in:[&quot;1013&quot;,&quot;1014&quot;]&#125;&#125;)\r\n\r\n不包含使用$nin操作符\r\n\r\n\r\n查询评论集合中userid字段不包含1013和1014的文档：\r\n\r\ndb.comment.find(&#123;userid:&#123;$nin:[&quot;1013&quot;,&quot;1014&quot;]&#125;&#125;)\r\n### 8.条件连接\r\n\r\n查询同时满足两个以上条件，需要使用$and操作符将条件进行关联（相当于SQL的and）。格式为：\r\n\r\n$and:[ &#123;条件&#125;,&#123;条件&#125;,&#123;条件&#125; ]\r\n\r\n查询评论集合中thumbup大于等于1000 并且小于2000的文档：\r\n\r\ndb.comment.find(&#123;$and:[ &#123;thumbup:&#123;$gte:1000&#125;&#125; ,&#123;thumbup:&#123;$lt:2000&#125; &#125;]&#125;)\r\n\r\n如果两个以上条件之间是或者的关系，使用操作符进行关联，与前面and的使用方式相同，格式为：\r\n\r\n$or:[ &#123;条件&#125;,&#123;条件&#125;,&#123;条件&#125; ]\r\n\r\n查询评论集合中userid为1013，或者点赞数小于2000的文档记录：\r\n\r\ndb.comment.find(&#123;$or:[ &#123;userid:&quot;1013&quot;&#125; ,&#123;thumbup:&#123;$lt:2000&#125; &#125;]&#125;)\r\n9.列值增长\r\n\r\n对某列值在原有值的基础上进行增加或减少，可以使用$inc运算符：\r\n\r\n\r\n正数增加\r\n\r\ndb.comment.update(&#123;_id:&quot;2&quot;&#125;,&#123;$inc:&#123;thumbup:1&#125;&#125;)\r\n\r\n负数减少\r\n\r\ndb.comment.update(&#123;_id:&quot;2&quot;&#125;,&#123;$inc:&#123;thumbup:-2&#125;&#125;)\r\n","categories":["非关系型数据库"],"tags":["mongDB","nosql"]},{"title":"vue常用指令","url":"/2020/09/15/vue%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","content":"v-bind（有简写方式）\r\n\r\n该指令用来动态修改标签中的属性信息\r\n\r\n动态绑定class有两种语法实现\r\n\r\n对象语法\r\n数组语法\r\n\r\n&lt;div id=&quot;app&quot;&gt;    &lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;    &lt;!--以下是简写方式--&gt;    &lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;    &lt;!--可以动态切换class来改变样式（以下使用的是对象语法）--&gt;    &lt;!--方法一--&gt;    &lt;div :class=&quot;&#123;a:is-a,b:is-b&#125;&quot;&gt;动态切换class&lt;/a&gt;    &lt;!--方法二--&gt;    &lt;div :class=&quot;getClasses()&quot;&gt;动态切换class&lt;/a&gt;&lt;/div&gt;\r\nvar app = new Vue(&#123;  el: &#x27;#app&#x27;,  data: &#123;    url: &quot;https://www.baidu.com&quot;,    is-a: true,    is-b: false    &#125;,  methods: &#123;      getClasses: function()&#123;          return &#123;a: this.is-a, b: this.is-b&#125;      &#125;  &#125;  &#125;)\r\n\r\nv-on（有简写方式）\r\n\r\n该指令用来绑定事件\r\n\r\n\r\n在调用方法时省略了小括号，但是方法本身是需要一个参数的，这个时候vue会默认将浏览器生成的event事件对象作为参数传入到方法中\r\n\r\n&lt;div id=&quot;app&quot;&gt;    &lt;a v-on:click=&quot;doSomething&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/a&gt;    &lt;!--以下是简写方式--&gt;    &lt;a @click=&quot;doSomething&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/a&gt;&lt;/div&gt;\r\nvar app = new Vue(&#123;  el: &#x27;#app&#x27;,  data: &#123;    message: &#x27;点击&#x27;  &#125;,  methods: &#123;      doSomething: function(event)&#123;          alert(&#x27;我被点击了&#x27;);          console.log(event);//接收来自浏览器生成的event      &#125;  &#125;  &#125;)\r\n\r\n如果往单击事件的方法中传入多个参数，要想在接收到浏览器生成的event事件，需要$event\r\n\r\n&lt;div id=&quot;app&quot;&gt;    &lt;a v-on:click=&quot;doSomething&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/a&gt;    &lt;!--以下是简写方式--&gt;    &lt;a @click=&quot;doSomething(&#x27;你好&#x27;,$event)&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/a&gt;&lt;/div&gt;\r\nvar app = new Vue(&#123;  el: &#x27;#app&#x27;,  data: &#123;    message: &#x27;点击&#x27;  &#125;,  methods: &#123;      doSomething: function(msg,event)&#123;          alert(msg);          console.log(event);//接收来自浏览器生成的event      &#125;  &#125;  &#125;)\r\nv-if、v-else、v-else-if\r\n\r\n该指令用来做判断，如果条件满足就渲染\r\n\r\nv-else-if用的少，因为判断条件比较复杂的话可以使用计算属性来判断，注意的是v-else-if不能单独使用\r\n&lt;div id=&quot;app&quot;&gt;    &lt;div v-if=&quot;isShow&quot;&gt;true显示&lt;/div&gt;    &lt;div v-else=&quot;isShow&quot;&gt;false显示&lt;/div&gt;&lt;/div&gt;\r\nvar app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;        isShow: true    &#125;&#125;);\r\nv-show\r\n\r\n该指令用来隐藏标签\r\n\r\n它和v-if指令的区别是v-if条件不满足不会进行渲染，而v-show一定会渲染，只是设置了隐藏属性（display）\r\n\r\n当显示隐藏切换频率高用v-show\r\n当只有一次切换使用v-if\r\n\r\n&lt;div id=&quot;app&quot;&gt;    &lt;div v-show=&quot;isShow&quot;&gt;显示&lt;/div&gt;    &lt;button @click=&quot;isShow=!isShow&quot;&gt;切换&lt;/button&gt;&lt;/div&gt;\r\nvar app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;        isShow: true    &#125;&#125;);\r\nv-for\r\n\r\n该指令用来遍历数组和对象\r\n\r\n\r\n遍历数组\r\n\r\n&lt;div id=&quot;app&quot;&gt;    &lt;ul&gt;        &lt;!--itm是元素，index是索引，items是数组--&gt;        &lt;li v-for=&quot;itm,index in items&quot;&gt;&#123;&#123;index&#125;&#125;--&#123;&#123;itm&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;\r\nvar app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;        items: [&quot;海王&quot;,&quot;狮王&quot;,&quot;虎王&quot;]    &#125;&#125;);\r\n\r\n遍历对象\r\n\r\n&lt;div id=&quot;app&quot;&gt;    &lt;!-- 写法一（只获取value） --&gt;    &lt;ul&gt;        &lt;li v-for=&quot;value in info&quot;&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt; &lt;!--单个只获取value --&gt;    &lt;/ul&gt;    &lt;!-- 写法二（获取key和value） --&gt;    &lt;ul&gt;        &lt;li v-for=&quot;value,key in info&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;value&#125;&#125;&lt;/li&gt;     &lt;/ul&gt;    &lt;!-- 写法三（获取key、value和索引） --&gt;    &lt;ul&gt;        &lt;li v-for=&quot;value,key,index in info&quot;&gt;&#123;&#123;index&#125;&#125;--&#123;&#123;key&#125;&#125;--&#123;&#123;value&#125;&#125;&lt;/li&gt;     &lt;/ul&gt;&lt;/div&gt;\r\nvar app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;        info: &#123;            name: &quot;李狗蛋&quot;,            age: 20,            sex: &quot;男&quot;        &#125;    &#125;&#125;);\r\nv-model\r\n\r\n该指令用来对表单元素数据进行双向绑定\r\n\r\n\r\n文本输入框text\r\n\r\n&lt;div id=&quot;app&quot;&gt;    &lt;!--v-model跟value属性绑定的--&gt;    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;    &#123;&#123;message&#125;&#125;&lt;/div&gt;\r\nvar app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;        message: &quot;hello&quot;    &#125;&#125;);\r\n\r\n单选框radio\r\n\r\n&lt;div id=&quot;app&quot;&gt;    &lt;!-- label标签可以实现点击文字就可触发相应绑定的标签 --&gt;    &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;男&quot; v-model=&quot;message&quot;/&gt;    &lt;br /&gt;    &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; value=&quot;女&quot; v-model=&quot;message&quot;/&gt;    你选择的性别是：&#123;&#123;message&#125;&#125;&lt;/div&gt;\r\nvar app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;        message: &quot;&quot;    &#125;&#125;);\r\n\r\n复选框checkbox（有单选和多选）\r\n\r\n&lt;div id=&quot;app&quot;&gt;    &lt;!-- 单选框 --&gt;    &lt;label for=&quot;agree&quot;&gt;同意协议&lt;/label&gt;    &lt;input type=&quot;checkbox&quot; id=&quot;agree&quot; name=&quot;agree&quot; v-model=&quot;isAgree&quot;/&gt;    &lt;p&gt;你选择的是：&#123;&#123;isAgree&#125;&#125;&lt;/p&gt;    &lt;button :disabled=&quot;!isAgree&quot;&gt;下一步&lt;/button&gt;    &lt;/br&gt;    &lt;!-- 多选框 --&gt;    篮球：&lt;input type=&quot;checkbox&quot; value=&quot;篮球&quot; v-model=&quot;hobbys&quot;&gt;    足球：&lt;input type=&quot;checkbox&quot; value=&quot;足球&quot; v-model=&quot;hobbys&quot;&gt;    台球：&lt;input type=&quot;checkbox&quot; value=&quot;台球&quot; v-model=&quot;hobbys&quot;&gt;    &lt;p&gt;爱好有：&#123;&#123;hobbys&#125;&#125;&lt;/p&gt;&lt;/div&gt;\r\nvar app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;        isAgree: false,        hobbys: []    &#125;&#125;);\r\n\r\n下选框select（单选和多选）\r\n\r\n&lt;div id=&quot;app&quot;&gt;    &lt;!-- 单选 --&gt;    &lt;select name=&quot;select&quot; v-model=&quot;fruit&quot;&gt;        &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;        &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt;        &lt;option value=&quot;西瓜&quot;&gt;西瓜&lt;/option&gt;        &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;    &lt;/select&gt;    &lt;p&gt;喜欢的水果是：&#123;&#123;fruit&#125;&#125;&lt;/p&gt;    &lt;!-- 多选 --&gt;    &lt;select name=&quot;select&quot; v-model=&quot;fruits&quot; multiple&gt;        &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;        &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt;        &lt;option value=&quot;西瓜&quot;&gt;西瓜&lt;/option&gt;        &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;    &lt;/select&gt;    &lt;p&gt;喜欢哪些水果：&#123;&#123;fruits&#125;&#125;&lt;/p&gt;&lt;/div&gt;\r\nvar app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;        fruit: &quot;葡萄&quot;,        fruits: []    &#125;&#125;);\r\nv-once\r\n\r\n使用该指令表示元素和组件只渲染一次，不会随着数据的变化而变化\r\n\r\n&lt;div id=&quot;app&quot; v-once&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;\r\nvar app = new Vue(&#123;  el: &#x27;#app&#x27;,  data: &#123;    message: &#x27;Hello Vue!&#x27;  &#125;&#125;)\r\nv-html\r\n\r\n使用该指令可以把字符串的数据在插值中显示时自动转换为HTML格式\r\n\r\n&lt;div id=&quot;app&quot; v-html=&quot;url&quot;&gt;&#123;&#123; url &#125;&#125;&lt;/div&gt;\r\nvar app = new Vue(&#123;  el: &#x27;#app&#x27;,  data: &#123;    url: &quot;&lt;a href=&#x27;https://www.baidu.com&#x27;&gt;百度一下&lt;/a&gt;&quot;  &#125;&#125;)\r\nv-pre\r\n\r\n该指令可以让插值语法不做任何解析，将原本的数据进行原封不动的展示\r\n\r\n&lt;div id=&quot;app&quot; v-pre&gt;&lt;/div&gt;\r\nvar app = new Vue(&#123;  el: &#x27;#app&#x27;,  data: &#123;    message: &quot;不生效&quot;  &#125;&#125;)\r\n","categories":["前端"],"tags":["vue"]}]